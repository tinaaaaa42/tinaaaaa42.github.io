{"posts":[{"title":"Effective Modern C++(1) 类型推导","text":"模板类型推导一个函数模板的伪代码类似这样： 12345template&lt;typename T&gt;void f(paramType param);// 调用f(expr); paramType 通常会带有一些修饰，比如const T&amp;等等。 情况一： paramType 是一个指针或引用，但不是通用引用12template&lt;typename T&gt;void f(T&amp; param); // param是一个引用 声明以下变量： 123int x = 42; // x是intconst int cx = x; // cx是const intconst int&amp; rx = cx; // rx是指向作为const int的x的引用 通过调用，类型推导如下： 123f(x); // T: int, param: int&amp;f(cx); // T: const int, param: const int&amp;f(rx); // T: const int, param: const int&amp; 根据上面的例子，在推导T时，常量型const-ness会被保留而引用性reference-ness会被忽略。 对paramType稍作变化也类似： 123456template&lt;typename T&gt;void f(const T&amp; param); // param现在是reference-to-constf(x); // T:int, param: const int&amp;f(cx); // T:int, param: const int&amp;f(rx); // T:int, param: const int&amp; 12345678template&lt;typename T&gt;void f(T* param) // param是指针int x = 42;const int *px = &amp;x; // px是指向作为const int的x的指针f(&amp;x); // T: int, param: int*f(px); // T: const int, param: const int* 情况二：paramType 是一个通用引用 如果expr是左值，T和paramType都会被推导为左值引用。这是模板类型推导唯一 T 被推导为引用的情况！ 如果expr是右值，则与情况一相同。 1234567891011template&lt;typename T&gt;void f(T&amp;&amp; param); // param是一个通用引用类型int x = 27;const int cx = x;const int&amp; rx = cx;f(x); // x是左值 =&gt; T: int&amp;, param: int&amp;f(cx); // cx是左值 =&gt; T: const int&amp;, param: const int&amp;f(rx); // rx是左值 =&gt; T: const int&amp;, param: const int&amp;f(42); // 42是右值 =&gt; T: int, param: int&amp;&amp; 情况三：paramType 既不是引用也不是指针此时通过传值pass-by-value的方式处理，也就是说 param 会作为一个完整的新对象，此时的到T的推导不仅忽略引用性reference-ness,常量性const-ness和volatile都会被忽略: 12345678910template&lt;typename T&gt;void f(T param); // 以传值的方式处理paramf(x); // T: int, param: intf(cx); // T: int, param: intf(rx); // T: int, param: intconst char* const ptr = &quot;Fun with pointers&quot;;// 此时ptr自身的值会传给形参f(ptr); // T/param: const char* 数组实参在函数参数中，数组常常会退化为指针。但利用引用，可以使得T推导为真正的数组！ 12345template&lt;typename T&gt;void f(T&amp; param);const char name[] = &quot;J, P, Briggs&quot;; // name类型为const char[13]f(name); // T: const char[13], param: const char (&amp;)[13] 根据这一点，我们还能写出推导数组大小的模板函数： 1234template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N;} autoauto声明的大部分情况与上述的模板类型推导相同： 123456789101112131415161718192021auto x = 27;const auto cx = x;const auto &amp; rx = cx;template&lt;typename T&gt; // 概念化的模板用来推导x的类型void func_for_x(T param);func_for_x(27); // 概念化调用(情景三) // param推导类型为x的类型template&lt;typename T&gt; // 概念化的模板用来推导cx的类型void func_for_cx(const T param);func_for_cx(x); // 概念化调用(情景三) // param推导类型为cx的类型template&lt;typename T&gt; // 概念化的模板用来推导rx的类型void func_for_rx(const T &amp; param);func_for_rx(cx); // 概念化调用(情景一) // param推导类型为rx的类型 情景二的例子： 123auto&amp;&amp; uref1 = x; // x是int左值 =&gt; uref1: int&amp;auto&amp;&amp; uref2 = cx; // cx是const int左值 =&gt; uref2: const int&amp;auto&amp;&amp; uref3 = 27; // 27是int右值 =&gt; uref3: int&amp;&amp; 对于non-reference类型说明符也是适用的： 123456789const char name[] = &quot;R. N. Briggs&quot;; // name是const char[13]auto arr1 = name; // arr1是const char*auto&amp; arr2 = name; // arr2是const char (&amp;)[13]void someFunc(int, double); // someFunc是类型为void(int, double)的函数auto func1 = someFunc; // func1是void (*)(int, double)auto&amp; func2 = someFunc; // func2是void (&amp;)(int, double) auto 的一个重要不同点是花括号的处理： 12auto x1 = {42};auto x2{42}; // 这两种初始化方式推导类型均为std::initializer_list&lt;int&gt; 而模板类型推导不会默认std::initializer_list&lt;T&gt;，事实上模板中无法处理: 123auto createInitList() { return {1, 2, 3}; // 无法通过编译！无法推导类型} 优先考虑auto声明而不是显式类型声明下面这个例子值得注意： 12345std::unordered_map&lt;std::string, int&gt; m;for (const std::pair&lt;std::string, int&gt;&amp; p : m) { // ...} 这样的写法会出现非常隐蔽的错误，因为hash table实际上存储的是std::pair&lt;const std::string, int&gt;，因此这里的p实际上是一份拷贝，而不是引用。如果我们使用auto声明，就不会出现这样的问题： 123for (const auto&amp; p : m) { // ...} auto的陷阱C++禁止对bit的引用，因此auto有一个典型的反例： 12345std::vector&lt;bool&gt; features(const Widget&amp; w);Widget w;auto highPriority = features(w)[5]; // highPriority是对bit的引用processWidget(w, highPriority); // 行为是不可预测的 std::vector&lt;bool&gt;的operator[]并不会返回bool的引用，而是返回了一个proxy对象std::vector&lt;bool&gt;::reference，由于该对象在这一行语句后被销毁，所以调用highPriority时会包含一个悬置dangling指针。 如果涉及到代理类的类型推导，一般可以使用显式类型初始器惯用法： 1auto highPriority = static_cast&lt;bool&gt;(features(w)[5]); decltypedecltype实际上只是返回参数的类型。在 C++11 中，它最主要就是用于声明函数模板，而返回类型依赖于形参类型： C++11的基本实现123456template&lt;typename Container, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) -&gt;decltype(c[i]) { // 使用了C++11的尾置返回类型语法 authenticateUser(); // 需要改良 return c[i];} C++14的基本实现(不那么正确)12345template&lt;typename Container, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} 由于模板类型推导时表达式的引用性的忽略，上面的这个实现并不正确，实际上可以这样写： C++14的基本实现123456template&lt;typename Container, typename Index&gt;decltype(auto) // C++14可以工作的版本authAndAccess(Container&amp; c, Index i) { // 还需要改进 authenticateUser(); return c[i];} 主要需要改进的地方就是处理右值，比如下面这样调用函数： 1234std::deque&lt;std::string&gt; makeStringDeque(); // 工厂函数// 从makeStringDeque中获得第五个元素的拷贝并返回auto s = authAndAccess(makeStringDeque(), 5); 除了重载的方法，我们也可以使用通用引用来实现： C++14的最终版本123456template&lt;typename Container, typename Index&gt;decltype(auto)authAndAccess(Container&amp;&amp; c, Index i) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} C++11的最终版本1234567template&lt;typename Container, typename Index&gt;autoauthAndAccess(Container&amp;&amp; c, Index i)-&gt;decltype(std::forward&lt;Container&gt;(x)[i]) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} 查看类型推导除了直接通过 IDE 查看类型推导结果(可能并不准确)，还有以下的方式： 编译器诊断可以利用编译器出错时提供的错误信息来获取类型信息。比如这样声明一个类模板： 12template&lt;typename T&gt;class TD; // type displayer 要查看变量的类型，通过这样故意的错误实例化： 1TD&lt;decltype(x)&gt; xType; 然后就能根据编译器给出的信息来推断 x 的类型。 运行时输出 利用typeid(T).name()获取信息，但由于传值的特性，该结果并不一定准确。 使用Boost.TypeIndex库","link":"/zh-CN/Effective-Modern-C-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"title":"Effective Modern C++(2) 移步现代C++(1)","text":"()和{}的选择C++11使用统一初始化uniform initialization来整合混乱的初始化语法，在一定程度上，{}的表达能力更强： 123456789101112int x{ 0 }; // 正确int y = 0; // 正确int z(0); // 错误！std::atomic&lt;int&gt; ai1{ 0 }; // 正确(不可拷贝的对象)std::atomic&lt;int&gt; ai2(0); // 正确std::atomic&lt;int&gt; ai3 = 0; // 错误！double x, y, z;int sum1{ x + y + z }; // 错误！int sum2(x + y + z); // 可以，但会截为intint sum3 = x + y + z; // 同上 同样值得注意的是最让人头疼的解析问题most vexing parse： 123Widget w1(10); // 传入实参10Widget w2(); // 声明一个函数，返回类型为WidgetWidget w3{}; // 调用默认构造函数 但是{}常常会出现std::initializer_list的问题，因此如果惯用了auto，那么选择{}就需要格外小心： 123456789101112class Widget {public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list&lt;long double&gt; il);};Widget w1(10, true); // 调用第一个构造函数Widget w2{10, true}; // 调用第三个构造函数Widget w3(10, 5.0); // 调用第二个构造函数Widget w4{10, 5.0}; // 调用第三个构造函数Widget w5{w4}; // 调用第三个构造函数 另一个corner case是实参为一个空的std::initializer_list： 123456Widget w1; // 调用默认构造函数Widget w2{}; // 调用默认构造函数Widget w3(); // 声明一个函数，返回类型为WidgetWidget w4({}); // 空初始化列表构造Widget w5{{}}; // 空初始化列表构造 在实际应用中，std::vector&lt;int&gt;是一个典型的例子： 12std::vector&lt;int&gt; v1(10, 20); // 10个20std::vector&lt;int&gt; v2{10, 20}; // 10和20 初始化列表构造 优先考虑nullptr而非0或NULLC++11引入了nullptr，它是一个特殊的类型，可以隐式转换为任意指针类型，但不会转换为整数类型。与0和NULL相比，nullptr不仅更加清晰易懂，而且更适配模板： 123456template&lt;typename FuncType, typename MuxType, typename PtrType&gt;decltype(auto) lockAndCall(FuncType func, MuxType&amp; mutex, PtrType ptr) { // 使用std::lock_guard保证互斥量在函数退出时解锁 std::lock_guard&lt;MuxType&gt; g(mutex); return func(ptr);} 优先考虑别名声明而非typedef首先是别名声明alias declaration在声明函数指针时更加易懂： 12typedef void (*FP)(int, const std::string&amp;); // typedefusing FP = void (*)(int, const std::string&amp;); // 别名声明 更重要的是别名声明可以声明模板别名： 12345template&lt;typename T&gt;using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; // 别名声明MyAllocList&lt;Widget&gt; lw; // 使用别名声明// 等价于std::list&lt;Widget, MyAlloc&lt;Widget&gt;&gt; lw; 如果一定要使用typedef： 123456template&lt;typename T&gt;struct MyAllocList { typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; // typedef};MyAllocList&lt;Widget&gt;::type lw; // 使用typedef 在模板元编程(template metaprogramming, TMP)中，常常会类型修饰的转换： 12345678std::remove_const&lt;T&gt;::type; // C++11 const T -&gt; Tstd::remove_const_t&lt;T&gt;; // C++14std::remove_reference&lt;T&gt;::type; // C++11 T&amp;/T&amp;&amp; -&gt; Tstd::remove_reference_t&lt;T&gt;; // C++14std::add_lvalue_reference&lt;T&gt;::type; // C++11 T -&gt; T&amp;std::add_lvalue_reference_t&lt;T&gt;; // C++14 我们自己要实现两个标准间的转换也只需要使用别名声明(注意要在依赖类型名前加上typename)： 12template&lt;typename T&gt;using remove_const_t = typename remove_const&lt;T&gt;::type; 优先使用限域的enum class而非enum通常来说{}内的声明是限域的，但是enum是个例外： 12enum Color { black, white, red }; // black, white, red在Color的作用域auto white = false; // 错误！white已经被声明 而使用C++11的enum class则不会出现这个问题： 12345enum class Color { black, white, red }; // black, white, red在Color的作用域auto white = false; // 正确！white不在Color的作用域Color c = white; // 错误！white不在作用域中Color c = Color::white; // 正确！auto c = Color::white; // 正确！ 除了防止命名空间污染，enum class也不像enum那样隐式转换，即要使用枚举值必须写明类型，如Color::white。 另外，enum class不仅可以提前声明，还可以指定底层类型： 1enum class Status: std::uint32_t; 但在某些情况下，非限域的enum也是很有用的，比如这个存储用户信息的例子： 1234using UserInfo = std::tuple&lt;std::string, std::string, std::size_t&gt;;enum UserInfoFields { uiName, uiEmail, uiReputation };UserInfo uInfo;auto val = std::get&lt;uiEmail&gt;(uInfo); 用enum class来写会较为繁琐： 123enum class UserInfoFields { uiName, uiEmail, uiReputation };UserInfo uInfo;auto val = std::get&lt;static_cast&lt;std::size_t&gt;(UserInfoFields::uiEmail)&gt;(uInfo); 但是可以使用一个辅助函数来简化： C++11 C++14 123456template&lt;typename E&gt;constexpr typename std::underlying_type&lt;E&gt;::type toUType(E enumerator) noexcept { return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(enumerator);} 12345template&lt;typename E&gt;constexpr autotoUType(E enumerator) noexcept { return static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(enumerator);} 然后就能通过toUType来获取枚举值了： 1auto val = std::get&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo); 优先考虑delete而非private在C++98中，禁用部分成员函数往往通过将其设为private并且不予定义来实现： C++98的声明12345678template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;class basic_ios : public ios_base {public: // ...private: basic_ios(const basic_ios&amp;); // 不予定义 basic_ios&amp; operator=(const basic_ios&amp;); // 不予定义}; 而在C++11中，可以使用delete来更好地实现： C++11的声明1234567template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;class basic_ios : public ios_base {public: // ... basic_ios(const basic_ios&amp;) = delete; // 标记为public可以获得更好的错误信息 basic_ios&amp; operator=(const basic_ios&amp;) = delete;}; 另外，delete可以用于任何函数： 1234bool isLucky(int number);bool isLucky(char) = delete; // 禁用char参数的isLuckybool isLucky(bool) = delete; // 禁用bool参数的isLuckybool isLucky(double) = delete; // 禁用double和float参数的isLucky delete也可以用于模板函数： 12345678template&lt;typename T&gt;void processPointer(T* ptr);template&lt;&gt;void processPointer&lt;void&gt;(void*) = delete; // 禁用void*参数的processPointertemplate&lt;&gt;void processPointer&lt;char&gt;(char*) = delete; // 禁用char*参数的processPointer 使用override声明重写函数在C++98的重写虚函数规定的基础上，C++11增加了一条规定：函数的引用限定符reference qualifier也必须相同： 1234567891011class Widget {public: virtual void doWork() &amp;; // 只有*this为左值时才能调用 virtual void doWork() &amp;&amp;; // 只有*this为右值时才能调用};Widget makeWidget(); // 工厂函数，返回右值Widget w; // 左值w.doWork(); // 调用Widget::doWork() &amp;makeWidget().doWork(); // 调用Widget::doWork() &amp;&amp; 通过将override放在函数声明后面，可以让编译器检查是否重写了基类的虚函数： 有关引用限定符还可以举一个例子： 1234567891011class Widget {public: using DataType = std::vector&lt;double&gt;; DataType&amp; data() &amp; { return values; } // 仅当*this为左值时调用(返回左值) DataType data() &amp;&amp; { return std::move(values); } // 仅当*this为右值时调用(返回右值)private: DataType values;};auto vals1 = w.data(); // vals1是左值，调用Widget::data() &amp;，拷贝构造auto vals2 = makeWidget().data(); // vals2是右值，调用Widget::data() &amp;&amp;，移动构造","link":"/zh-CN/Effective-Modern-C-2-%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3C/"},{"title":"Effective Modern C++(3) 移步现代C++(2)","text":"优先考虑const_iterator而非iterator考虑如下的代码： C++98的实现1234std::vector&lt;int&gt; values;...std::vector&lt;int&gt;::iterator it = std::find(values.begin(), values.end(), 1983);values.insert(it, 1998); 这里使用iterator实际上不是一个好的选择，因为这段代码并不改变其指向的内容。使用C++11中的const iterator更为合理： C++11的实现1234std::vector&lt;int&gt; values;...auto it = std::find(values.cbegin(), values.cend(), 1983); // 使用cbegin和cendvalues.insert(it, 1998); C++14中的支持程度更高，加入了cbegin，cend，rbegin，rend，crbegin，crend。 不抛出异常的函数使用noexcept优化！123RetType function(params) noexcept; // 极尽所能优化RetType function(params) throw(); // 较少优化（C++98）RetType function(params); // 较少优化 swapswap函数在STL中大量使用，因此对其使用不抛异常的优化是非常有价值的。有趣的是，标准库的swap是否noexcept有时依赖于用户定义的swap是否noexcept： 数组和std::pair的swap声明123456789template&lt;typename T, size_t N&gt;void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));template&lt;typename T1, typename T2&gt;struct pair { ... void swap(pair&amp; p) noexcept(noexcept(swap(first, p.first)) &amp;&amp; noexcept(swap(second, p.second))); ...}; 尽可能使用constexprconstexpr对象constexpr对象是编译期可知的(更准确的说法是翻译期translation)： 123456789int sz; // 非constexprconstexpr auto arraySize1 = sz; // 错误，sz值在编译期未知std::array&lt;int, sz&gt; data1; // 错误，sz值在编译期未知constexpr auto arraySize2 = 10; // 正确，10是常量表达式std::array&lt;int, arraySize2&gt; data2; // 正确，arraySize2是常量表达式const auto arraySize3 = sz; // 正确，arraySize是sz的const复制std::array&lt;int, arraySize3&gt; data3; // 错误，arraySize3的值在编译期未知 constexpr函数对于constexpr函数，如果实参是编译期常量，函数将产出编译期常量；如果实参在运行时才知道，函数就产出运行时值。 整数pow1234567constexprint pow(int base, int exp) noexcept { ...}constexpr auto numConds = 5;std::array&lt;int, pow(3, numConds)&gt; results; // 编译期可知大小 在C++11中，constexpr函数只能有一行return语句： C++11实现整数pow123constexpr int pow(int base, int exp) noexcept { return (exp == 0 ? 1 : base * pow(base, exp - 1));} C++14constexpr函数的限制十分宽松： C++14实现整数pow123456constexpr int pow(int base, int exp) noexcept { auto result = 1; for (itn i = 0; i &lt; exp; ++i) result *= base; return result;} 在C++11中，除了void的类型都可以是字面值类型。下面考虑一个自定义的类型： 123456789101112131415class Point {public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) {} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setX(double newX) noexcept { x = newX; }private: double x, y;} 将构造函数声明为constexpr，则如果传入的参数在编译期可知，那么Point的数据成员也在编译期可知。 在C++14中，const和void的限制被放开，因此上面两个setter函数也能被声明为constexpr。 让const成员函数线程安全使用互斥量mutex考虑一个多项式类： 多项式类求根123456789101112131415161718class Polynomial {public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { if (!rootsAreValid) { // 计算多项式的根 ... rootsAreValid = true; } return rootVals; }private: mutable bool rootsAreValid{false}; mutable RootsType rootVals{};}; 但上述函数并不是线程安全的，可能会出现不同线程读写相同内存的情况。要解决这个问题最简单的办法就是使用互斥量mutex： 多项式类求根(线程安全)1234567891011121314151617181920class Polynomial {public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { std::lock_guard&lt;std::mutex&gt; g(m); // 加锁 if (!rootsAreValid) { // 计算多项式的根 ... rootsAreValid = true; } return rootVals; } // 解锁private: mutable bool rootsAreValid{false}; mutable RootsType rootVals{}; mutable std::mutex m; // 互斥量}; std::atomic某些情况下，互斥量的开销可能过大，这时可以考虑使用std::atomic： 多项式类记录调用次数(线程安全)12345678910111213class Polynomial {public: ... double distanceFromOrigin() const noexcept { ++callCount; // 记录调用次数 ... return std::sqrt((x * x) + (y * y)); }private: mutable std::atomic&lt;unsigned&gt; callCount{0}; // 记录调用次数 double x, y;}; 但要注意std::atomic只适合操作单个变量或者内存位置。 特殊成员函数的生成特殊生成函数指的是C++自己生成的函数。C++98中包括默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符；C++11中加入了移动构造函数和移动赋值运算符。 C++11新的特殊生成函数123456class Widget {public: ... Widget(Widget&amp;&amp; rhs); // 移动构造函数 Widget&amp; operator=(Widget&amp;&amp; rhs); // 移动赋值运算符}; Rule of Three原则：如果声明了拷贝构造函数、拷贝复制运算符、析构函数中的任意一个，那么就应该声明另外两个。 C++11仅当下面条件成立时才会生成移动操作(当需要时)： 类没有拷贝操作 类没有移动操作 类没有用户定义的析构函数 如果编译器生成的函数行为是正确的，可以使用C++11的=default来显式声明： 1234567class Widget {public: ... ~Widget(); Widget(const Widget&amp;) = default; Widget&amp; operator=(const Widget&amp;) = default;}; 这样的做法在多态基类中很有用： 多态基类1234567891011class Base {public: virtual ~Base() = default; // 使析构函数virtual Base(Base&amp;&amp;) = default; // 支持移动 Base&amp; operator=(Base&amp;&amp;) = default; Base(const Base&amp;) = default; // 支持拷贝 Base&amp; operator=(const Base&amp;) = default; ...};","link":"/zh-CN/Effective-Modern-C-3-%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3C-2/"},{"title":"icarus的一些用法","text":"本文引自https://blog.geektime.club/posts/8917 自定义效果突出提示栏 谷歌网址为www.google.com 本文同时提供如下语言的翻译：English 文章内容有误？请点击此处提交修改。 第一种-页面内提示123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-circle-info mr-2&quot;&gt;&lt;/i&gt;谷歌网址为&lt;a href=&quot;https://www.google.com&quot;&gt;www.google.com&lt;/a&gt; &lt;/div&gt;&lt;/article&gt; 下面这种方式实际实现的是站内的跳转，因此需要使用post_path变量。 第二种-站内跳转123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;本文同时提供如下语言的翻译：&lt;a href=&quot;&quot;&gt;English&lt;/a&gt; &lt;/div&gt;&lt;/article&gt; 第三种与第一种是类似的。 第三种 >folded123456&lt;article class=&quot;message message-immersive is-warning&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？请点击&lt;a href=&quot;https://github.com/tinaaaaa42&quot;&gt;此处&lt;/a&gt;提交修改。 &lt;/div&gt;&lt;/article&gt; 摘要要实现文章的摘要内容只显示在首页而不显示在正文，有以下两种办法： Front-matter可以将文章的摘要写在 md 文件开头的front-matter信息中： 文章xxx.md123456---......excerpt: 这里是摘要---这里是正文 Bulma也可以采用在正文中使用Bulma搭配 HTML 标签: 文章xxx.md1234567891011这里的内容会出现在简介和正文&lt;div class=&quot;post-summary&quot;&gt;这里的内容只会出现在简介&lt;/div&gt;&lt;!--more--&gt;&lt;style type=&quot;text/css&quot;&gt; .post-summary{ display:none; }&lt;/style&gt; 页内标签页页内标签页可以实现代码块的平行显示，即只会显示当前活跃的标签内容，比如icarus官网上的这个效果： 从源码安装 使用 从 Github 仓库安装… 使用 NPM 安装为 node 包… 具体实现代码如下： 页内标签页语法定义123456789101112131415{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签id&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签id&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} tabs 第一页 第二页 这是small标签页容器的第一页 这是small标签页容器的第二页 第一页 第二页 这是默认标签页容器的第一页 这是默认标签页容器的第二页 第一页 第二页 这是medium标签页容器的第一页 这是medium标签页容器的第二页 第一页 第二页 这是large标签页容器的第一页 这是large标签页容器的第二页 align 第一页 第二页 这是默认标签页容器的第一页 这是默认标签页容器的第二页 第一页 第二页 这是centered标签页容器的第一页 这是centered标签页容器的第二页 第一页 第二页 这是right标签页容器的第一页 这是right标签页容器的第二页 第一页 第二页 这是fullwidth标签页容器的第一页 这是fullwidth标签页容器的第二页 style 第一页 第二页 这是boxed标签页容器的第一页 这是boxed标签页容器的第二页 第一页 第二页 这是toggle标签页容器的第一页 这是toggle标签页容器的第二页 第一页 第二页 这是toggle-rounded标签页容器的第一页 这是toggle-rounded标签页容器的第二页 彩色提示消息带颜色的消息提示能使信息更加醒目，其语法格式如下： 彩色消息提示语法定义123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %}&lt;消息内容&gt;{% endmessage %} color default 这是默认颜色的消息块 dark 这是dark颜色的消息块 primary 这是primary颜色的消息块 info 这是info颜色的消息块 success 这是success颜色的消息块 warning 这是warning颜色的消息块 danger 这是danger颜色的消息块 size small 这是small大小的消息块 default 这是default大小的消息块 medium 这是medium大小的消息块 large 这是large大小的消息块 icon Github图标消息块 这是&quot;icon:fa-brands fa-github&quot;图标的消息块 Nodejs图标消息块 这是&quot;icon:fa-brands fa-node-js&quot;图标的消息块 title 这是没有title的消息块 Hexo 内置专用标签插件引用块123{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %} 代码块123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} iframe1{% iframe url [width] [height] %} image1{% img [class names] /path/to/image [width] [height] '&quot;title text&quot; &quot;alt text&quot;' %} link1{% link text url [external] [title] %} youtube1234{% youtube video_id [type] [cookie] %}// [type]：默认为空，可选 playlist (播放列表)// [cookie]: 默认为true，可选false 一个例子：","link":"/zh-CN/icarus%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"},{"title":"我的neovim配置","text":"我的 neovim 配置基于油管上的这个视频，非常细致的老哥！ 在这一篇记录中不会涉及很多原理，基本用于个人的 cheat sheet。 Basic File Structure123456789101112131415~/.config/|__ nvim/ |__ init.lua |__ lua/ |__ young/ |__ core/ | |__ colorscheme.lua | |__ options.lua | |__ keymaps.lua |__ plugins/ | |__ lualine.lua | |__ telescope.lua | |__ nvim-tree.lua | |__ .... |__ plugins-setup.lua 基本 options 配置这部分内容在文件中比较容易看懂，也容易修改，不做赘述。 基本 keymaps 设置leader-key为空格 INSERT模式下按jk等同于&lt;ESC&gt;，即返回NORMAL模式 查找后通过空格+nh 跳转到特定位置并取消高亮 NORMAL模式下通过x删除不复制进 Clipboard NORMAL模式下通过空格+/-对值进行递增/递减 split windows(NORMAL模式) 空格+sv 生成竖直窗口 空格+sh 生成水平窗口 空格+se 使窗口等大 空格+sx 关闭当前窗口 tabs(NORMAL模式) 空格+to 打开新的 tab 空格+tx 关闭当前 tab 空格+tn 到下一个 tab 空格+tp 到前一个 tab Plugins使用Packer作为插件管理器，基本按照文档完成plugins-setup.lua文件的框架。并在init.lua文件最上方加入: 1require(&quot;young.plugins-setup&quot;) 配色plugins-setup.lua1use(&quot;bluz71/vim-nightfly-guicolors&quot;) 并在colorscheme.lua文件中指定。 Navigatorplugins-setup.lua1use(&quot;christoomey/vim-tmux-navigator&quot;) 通过Ctrl+h/j/k/l实现窗口间的移动 Maximizerplugins-setup.lua1use(&quot;szw/vim-maximizer&quot;) 在keymaps.lua中设置空格+sm 将当前窗口最大化或恢复 Essentialplugins-setup.lua12use(&quot;tpope/vim-surround&quot;)use(&quot;vim-scripts/ReplaceWithRegister&quot;) ys+w+” 在该单词两边加双引号 ds+” 去掉两边的双引号 cs+”+’ 将两边的双引号改为单引号 yw 复制当前词，grw 替换为复制的词 Commentplugins-setup.lua1use(&quot;numToStr/Comment.nvim&quot;) 在plugins文件夹中创建comment.lua，完成 setup 后在init.lua中 require 通过 gc+指定内容进行注释或者取消注释，如 gcc 注释本行，gc9j 注释九行。 File Exploreplugins-setup.lua1use(&quot;nvim-tree/nvim-tree.lua&quot;) 在plugins文件夹中创建nvim-tree.lua，完成 setup 后在init.lua中 require通过:NvimTreeToggle或设置快捷键空格+e 调出 File Tree在光标在对应文件夹中时按 a 并在下方输入栏中输入文件名即可创建新文件 要支持 icon 使用： plugins-setup.lua1use(&quot;kyazdani42/nvim-web-devicons&quot;) Status lineplugins-setup.lua1use(&quot;nvim-lualine/lualine.nvim&quot;) 在plugins文件夹中创建lualine.lua，完成 setup 后在init.lua中 require Fuzzy findingplugins-setup.lua12use({&quot;nvim-telescope/telescope-fzf-native.nvim&quot;, run=&quot;make&quot;})use({&quot;nvim-telescope/telescope.nvim&quot;, branch=&quot;0.1.x&quot;}) 在plugins文件夹中创建telescope.lua，完成 setup 后在init.lua中 require keymaps 设置： 空格+ff 在项目中寻找文件(find files) 空格+fs 在项目中寻找文字 空格+fc 在项目中寻找当前的 string 空格+fb 显示 telescope 的 buffer 空格+fh 显示 telescope 的帮助 多个匹配通过Ctrl+j/k上下移动 Autocompletion and Snippetsplugins-setup.lua1234567use(&quot;hrsh7th/nvim-cmp&quot;)use(&quot;hrsh7th/cmp-buffer&quot;)use(&quot;hrsh7th/cmp-path&quot;)use(&quot;L3MON4D3/LuaSnip&quot;)use(&quot;saadparwaiz1/cmp_luasnip&quot;)use(&quot;rafamadriz/friendly-snippets&quot;) 在plugins文件夹中创建nvim-cmp.lua，完成 setup 后在init.lua中 require在补全建议中，通过Ctrl+j/k上下选择，Ctrl+b/f上下翻页，Ctrl+e关闭，回车选择 LSPplugins-setup.lua1234567891011121314151617-- managing &amp; installing lsp serversuse(&quot;williamboman/mason.nvim&quot;)use(&quot;williamboman/mason-lspconfig.nvim&quot;)-- configuring lsp serversuse(&quot;neovim/nvim-lspconfig&quot;)use(&quot;hrsh7th/cmp-nvim-lsp&quot;) -- for autocompletionuse({ &quot;glepnir/lspsaga.nvim&quot;, branch = &quot;main&quot;, requires = { { &quot;nvim-tree/nvim-web-devicons&quot; }, { &quot;nvim-treesitter/nvim-treesitter&quot; }, },}) -- enhanced lsp uisuse(&quot;jose-elias-alvarez/typescript.nvim&quot;) -- additional functionality for typescript server (e.g. rename file &amp; update imports)use(&quot;onsails/lspkind.nvim&quot;) -- vs-code like icons for autocompletion 在plugins文件夹中创建lua文件夹，然后在lua文件夹中创建mason.lua，完成 mason 的 setup 后指定需要 lsp 的语言，再在init.lua中 require 再在lua文件夹中创建lspconfig.lua，按照文档完成各 lsp 的配置后在init.lua中 require 再在lua文件夹中创建lspsaga.lua，设定Ctrl+f/b为上下翻页后，在init.lua中 require gf show definitions and references gD goto declaration gd see the definition and make edition gi goto implementation 空格+ca see available code actions 空格+rn smart rename 空格+D show diagnostics for line 空格+d show diagnostic for cursor [d jump to previous diagnostic in buffer ]d jump to next diagnostic in buffer K show documentation for what is under cursor 空格+o show outline on the right side formatting &amp; lintingplugins-setup.lua12use(&quot;jose-elias-alvarez/null-ls.nvim&quot;)use(&quot;jayp0521/mason-null-ls.nvim&quot;) 在lua文件夹中创建null-ls.lua，完成 setup 后在init.lua中 require Treesitter &amp; Auto closingplugins-setup.lua12345678910use({ &quot;nvim-treesitter/nvim-treesitter&quot;, run = function() local ts_update = require(&quot;nvim-treesitter.install&quot;).update({ with_sync = true }) ts_update() end,})use(&quot;windwp/nvim-autopairs&quot;) -- autoclose parens, brackets, quotes, etc...use({ &quot;windwp/nvim-ts-autotag&quot;, after = &quot;nvim-treesitter&quot; }) -- autoclose tags autopairs.lua + treesitter.lua git integrationplugins-setup.lua1use(&quot;lewis6991/gitsigns.nvim&quot;) gitsigns.lua TmuxTmux可以方便在一个界面内打开多个命令行窗口，我的配置同样是参考这位老哥的视频。 Command Line tmux new -s Session 创建并进入一个名为Session的 session tmux detach 退出 session tmux ls 列出当前所有 session tmux attach -t Session 进入已存在的名为Session的 session exit 关闭当前窗口 keymaps 设置prefix键为Ctrl+a prefix+s 显示所有 session 并可以通过 j/k 选择进入 prefix+| 生成垂直窗口 prefix+- 生成水平窗口 prefix+r 刷新配置 prefix+j/k/h/l 调整窗口大小 prefix+m 当前窗口最大化或恢复 Ctrl+j/k/h/l 光标在窗口间移动 prefix+c 创建新的窗口（全屏），随后可用 prefix+编号 进行窗口选择 prefix+, 进行重命名 prefix+p/n 前一个或后一个窗口 prefix+w 显示所有的 session 和窗口 命令行界面可以通过j/k上下移动，Ctrl+u/d上下半页，Ctrl+b/f上下页也可以通过y进行复制 prefix+I 下载插件","link":"/zh-CN/%E6%88%91%E7%9A%84neovim%E9%85%8D%E7%BD%AE/"},{"title":"Effective Modern C++(4) 智能指针(1)","text":"对独占资源使用std::unique_ptr作为一种只可移动类型(move-only type)，std::unique_ptr体现了专有所有权(exclusive ownership)。std::unique_ptr最常见的用法是作为继承层次结构中对象的工厂函数的返回类型。考虑这样的类型： 1234class Investment { ... };class Stock : public Investment { ... };class Bond : public Investment { ... };class RealEstate : public Investment { ... }; Investment继承关系的工厂函数可以这样声明： 12template&lt;typename... Ts&gt;std::unique_ptr&lt;Investment&gt; makeInvestment(Ts&amp;&amp;... params); 调用者在单独的作用域中使用返回的std::unique_ptr： 1234{ auto pInvestment = makeInvestment(...); // 调用工厂函数 ...} // pInvestment被销毁 除了采用默认的delete销毁器，std::unique_ptr还可以采用自定义的销毁器： 12345678910111213141516171819auto delInvmt = [](Investment* pInvestment) { makeLogEntry(pInvestment); // 记录销毁的对象 delete pInvestment; // Investment必须有虚析构函数};template&lt;typename... Ts&gt;std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;makeInvestment(Ts&amp;&amp;... params) { std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt); if (/*一个Stock对象应该被创建*/) { pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个Bond对象应该被创建*/) { pInv.reset(new Bond(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个RealEstate对象应该被创建*/) { pInv.reset(new RealEstate(std::forward&lt;Ts&gt;(params)...)); } return pInv;} 由于原始指针(比如new创建的)赋值给std::unique是无法通过编译的，所以这里使用了reset函数。 C++14中可以推导函数的返回类型，因而可以有更简单的封装： 1234567891011121314151617template&lt;typename... Ts&gt;auto makeInvestment(Ts&amp;&amp;... params) { auto delInvmt = [](Investment* pInvestment) { // 利用无状态函数对象(如lambda) makeLogEntry(pInvestment); // 不影响std::unique_ptr的大小 delete pInvestment; }; std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt); if (/*一个Stock对象应该被创建*/) { pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个Bond对象应该被创建*/) { pInv.reset(new Bond(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个RealEstate对象应该被创建*/) { pInv.reset(new RealEstate(std::forward&lt;Ts&gt;(params)...)); } return pInv;} 共享资源使用std::shared_ptrstd::shared_ptr代表着共享所有权，它通过引用计数(reference count)来关联资源并跟踪指向该资源的指针数量。std::shared_ptr在自定义删除器上与std::unique_ptr有所不同： 1234567auto loggingDel = [](Widget *pw) { makeLogEntry(pw); delete pw;};std::unique_ptr&lt;Widget, decltype(loggingDel)&gt; upw(new Widget, loggingDel);std::shared_ptr&lt;Widget&gt; spw(new Widget, loggingDel); // 不同std::shared_ptr可以使用不同的删除器 std::shared_ptr对象在内存中实际是这样的： 控制块的构造遵循以下原则： std::shared_ptr的构造函数会创建一个控制块 从独占指针(std::unique_ptr)构造std::shared_ptr时创建控制块 从原始指针上构造出std::shared_ptr时创建控制块 因此按照以下的声明： 一个错误的做法123auto pw = new Widget;std::shared_ptr&lt;Widget&gt; spw1(pw, loggingDel);std::shared_ptr&lt;Widget&gt; spw2(pw, loggingDel); 这样会使pw被销毁两次！因此应当尽可能使用std::make_shared，如果需要自定义的删除器，应当直接使用new的结果： 合理的做法12std::shared_ptr&lt;Widget&gt; spw1(new Widget, loggingDel);std::shared_ptr&lt;Widget&gt; spw2(spw1); 另一个需要注意的地方是使用this指针作为std::shared_ptr构造函数实参的时候可能导致创建多个控制块： 123456789std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets; // 跟踪已处理的Widgetclass Widget {public: ... void process() { processedWidgets.emplace_back(this); // 创建一个新的控制块 } ...}; 但成员函数外也存在指向该Widget对象的指针，因此应当使用std::enable_shared_from_this： 123456789101112131415class Widget : public std::enable_shared_from_this&lt;Widget&gt; {public: // 完美转发参数给private构造函数的工厂函数 template&lt;typename... Ts&gt; static std::shared_ptr&lt;Widget&gt; create(Ts&amp;&amp;... params) { return std::shared_ptr&lt;Widget&gt;(new Widget(std::forward&lt;Ts&gt;(params)...)); } ... void process() { processedWidgets.emplace_back(shared_from_this()); // 使用已有的控制块 } ...private: ... // 构造函数};","link":"/zh-CN/Effective-Modern-C-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1/"}],"tags":[{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"C++14","slug":"C-14","link":"/tags/C-14/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"vim","slug":"vim","link":"/tags/vim/"}],"categories":[{"name":"Effective Modern C++","slug":"Effective-Modern-C","link":"/categories/Effective-Modern-C/"},{"name":"beginning","slug":"beginning","link":"/categories/beginning/"}],"pages":[{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}