{"posts":[{"title":"Effective Modern C++(1) 类型推导","text":"模板类型推导一个函数模板的伪代码类似这样： 12345template&lt;typename T&gt;void f(paramType param);// 调用f(expr); paramType 通常会带有一些修饰，比如const T&amp;等等。 情况一： paramType 是一个指针或引用，但不是通用引用12template&lt;typename T&gt;void f(T&amp; param); // param是一个引用 声明以下变量： 123int x = 42; // x是intconst int cx = x; // cx是const intconst int&amp; rx = cx; // rx是指向作为const int的x的引用 通过调用，类型推导如下： 123f(x); // T: int, param: int&amp;f(cx); // T: const int, param: const int&amp;f(rx); // T: const int, param: const int&amp; 根据上面的例子，在推导T时，常量型const-ness会被保留而引用性reference-ness会被忽略。 对paramType稍作变化也类似： 123456template&lt;typename T&gt;void f(const T&amp; param); // param现在是reference-to-constf(x); // T:int, param: const int&amp;f(cx); // T:int, param: const int&amp;f(rx); // T:int, param: const int&amp; 12345678template&lt;typename T&gt;void f(T* param) // param是指针int x = 42;const int *px = &amp;x; // px是指向作为const int的x的指针f(&amp;x); // T: int, param: int*f(px); // T: const int, param: const int* 情况二：paramType 是一个通用引用 如果expr是左值，T和paramType都会被推导为左值引用。这是模板类型推导唯一 T 被推导为引用的情况！ 如果expr是右值，则与情况一相同。 1234567891011template&lt;typename T&gt;void f(T&amp;&amp; param); // param是一个通用引用类型int x = 27;const int cx = x;const int&amp; rx = cx;f(x); // x是左值 =&gt; T: int&amp;, param: int&amp;f(cx); // cx是左值 =&gt; T: const int&amp;, param: const int&amp;f(rx); // rx是左值 =&gt; T: const int&amp;, param: const int&amp;f(42); // 42是右值 =&gt; T: int, param: int&amp;&amp; 情况三：paramType 既不是引用也不是指针此时通过传值pass-by-value的方式处理，也就是说 param 会作为一个完整的新对象，此时的到T的推导不仅忽略引用性reference-ness,常量性const-ness和volatile都会被忽略: 12345678910template&lt;typename T&gt;void f(T param); // 以传值的方式处理paramf(x); // T: int, param: intf(cx); // T: int, param: intf(rx); // T: int, param: intconst char* const ptr = &quot;Fun with pointers&quot;;// 此时ptr自身的值会传给形参f(ptr); // T/param: const char* 数组实参在函数参数中，数组常常会退化为指针。但利用引用，可以使得T推导为真正的数组！ 12345template&lt;typename T&gt;void f(T&amp; param);const char name[] = &quot;J, P, Briggs&quot;; // name类型为const char[13]f(name); // T: const char[13], param: const char (&amp;)[13] 根据这一点，我们还能写出推导数组大小的模板函数： 1234template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N;} autoauto声明的大部分情况与上述的模板类型推导相同： 123456789101112131415161718192021auto x = 27;const auto cx = x;const auto &amp; rx = cx;template&lt;typename T&gt; // 概念化的模板用来推导x的类型void func_for_x(T param);func_for_x(27); // 概念化调用(情景三) // param推导类型为x的类型template&lt;typename T&gt; // 概念化的模板用来推导cx的类型void func_for_cx(const T param);func_for_cx(x); // 概念化调用(情景三) // param推导类型为cx的类型template&lt;typename T&gt; // 概念化的模板用来推导rx的类型void func_for_rx(const T &amp; param);func_for_rx(cx); // 概念化调用(情景一) // param推导类型为rx的类型 情景二的例子： 123auto&amp;&amp; uref1 = x; // x是int左值 =&gt; uref1: int&amp;auto&amp;&amp; uref2 = cx; // cx是const int左值 =&gt; uref2: const int&amp;auto&amp;&amp; uref3 = 27; // 27是int右值 =&gt; uref3: int&amp;&amp; 对于non-reference类型说明符也是适用的： 123456789const char name[] = &quot;R. N. Briggs&quot;; // name是const char[13]auto arr1 = name; // arr1是const char*auto&amp; arr2 = name; // arr2是const char (&amp;)[13]void someFunc(int, double); // someFunc是类型为void(int, double)的函数auto func1 = someFunc; // func1是void (*)(int, double)auto&amp; func2 = someFunc; // func2是void (&amp;)(int, double) auto 的一个重要不同点是花括号的处理： 12auto x1 = {42};auto x2{42}; // 这两种初始化方式推导类型均为std::initializer_list&lt;int&gt; 而模板类型推导不会默认std::initializer_list&lt;T&gt;，事实上模板中无法处理: 123auto createInitList() { return {1, 2, 3}; // 无法通过编译！无法推导类型} 优先考虑auto声明而不是显式类型声明下面这个例子值得注意： 12345std::unordered_map&lt;std::string, int&gt; m;for (const std::pair&lt;std::string, int&gt;&amp; p : m) { // ...} 这样的写法会出现非常隐蔽的错误，因为hash table实际上存储的是std::pair&lt;const std::string, int&gt;，因此这里的p实际上是一份拷贝，而不是引用。如果我们使用auto声明，就不会出现这样的问题： 123for (const auto&amp; p : m) { // ...} auto的陷阱C++禁止对bit的引用，因此auto有一个典型的反例： 12345std::vector&lt;bool&gt; features(const Widget&amp; w);Widget w;auto highPriority = features(w)[5]; // highPriority是对bit的引用processWidget(w, highPriority); // 行为是不可预测的 std::vector&lt;bool&gt;的operator[]并不会返回bool的引用，而是返回了一个proxy对象std::vector&lt;bool&gt;::reference，由于该对象在这一行语句后被销毁，所以调用highPriority时会包含一个悬置dangling指针。 如果涉及到代理类的类型推导，一般可以使用显式类型初始器惯用法： 1auto highPriority = static_cast&lt;bool&gt;(features(w)[5]); decltypedecltype实际上只是返回参数的类型。在 C++11 中，它最主要就是用于声明函数模板，而返回类型依赖于形参类型： C++11的基本实现123456template&lt;typename Container, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) -&gt;decltype(c[i]) { // 使用了C++11的尾置返回类型语法 authenticateUser(); // 需要改良 return c[i];} C++14的基本实现(不那么正确)12345template&lt;typename Container, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} 由于模板类型推导时表达式的引用性的忽略，上面的这个实现并不正确，实际上可以这样写： C++14的基本实现123456template&lt;typename Container, typename Index&gt;decltype(auto) // C++14可以工作的版本authAndAccess(Container&amp; c, Index i) { // 还需要改进 authenticateUser(); return c[i];} 主要需要改进的地方就是处理右值，比如下面这样调用函数： 1234std::deque&lt;std::string&gt; makeStringDeque(); // 工厂函数// 从makeStringDeque中获得第五个元素的拷贝并返回auto s = authAndAccess(makeStringDeque(), 5); 除了重载的方法，我们也可以使用通用引用来实现： C++14的最终版本123456template&lt;typename Container, typename Index&gt;decltype(auto)authAndAccess(Container&amp;&amp; c, Index i) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} C++11的最终版本1234567template&lt;typename Container, typename Index&gt;autoauthAndAccess(Container&amp;&amp; c, Index i)-&gt;decltype(std::forward&lt;Container&gt;(x)[i]) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} 查看类型推导除了直接通过 IDE 查看类型推导结果(可能并不准确)，还有以下的方式： 编译器诊断可以利用编译器出错时提供的错误信息来获取类型信息。比如这样声明一个类模板： 12template&lt;typename T&gt;class TD; // type displayer 要查看变量的类型，通过这样故意的错误实例化： 1TD&lt;decltype(x)&gt; xType; 然后就能根据编译器给出的信息来推断 x 的类型。 运行时输出 利用typeid(T).name()获取信息，但由于传值的特性，该结果并不一定准确。 使用Boost.TypeIndex库","link":"/zh-CN/Effective-Modern-C-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"title":"Effective Modern C++(2) 移步现代C++(1)","text":"()和{}的选择C++11使用统一初始化uniform initialization来整合混乱的初始化语法，在一定程度上，{}的表达能力更强： 123456789101112int x{ 0 }; // 正确int y = 0; // 正确int z(0); // 错误！std::atomic&lt;int&gt; ai1{ 0 }; // 正确(不可拷贝的对象)std::atomic&lt;int&gt; ai2(0); // 正确std::atomic&lt;int&gt; ai3 = 0; // 错误！double x, y, z;int sum1{ x + y + z }; // 错误！int sum2(x + y + z); // 可以，但会截为intint sum3 = x + y + z; // 同上 同样值得注意的是最让人头疼的解析问题most vexing parse： 123Widget w1(10); // 传入实参10Widget w2(); // 声明一个函数，返回类型为WidgetWidget w3{}; // 调用默认构造函数 但是{}常常会出现std::initializer_list的问题，因此如果惯用了auto，那么选择{}就需要格外小心： 123456789101112class Widget {public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list&lt;long double&gt; il);};Widget w1(10, true); // 调用第一个构造函数Widget w2{10, true}; // 调用第三个构造函数Widget w3(10, 5.0); // 调用第二个构造函数Widget w4{10, 5.0}; // 调用第三个构造函数Widget w5{w4}; // 调用第三个构造函数 另一个corner case是实参为一个空的std::initializer_list： 123456Widget w1; // 调用默认构造函数Widget w2{}; // 调用默认构造函数Widget w3(); // 声明一个函数，返回类型为WidgetWidget w4({}); // 空初始化列表构造Widget w5{{}}; // 空初始化列表构造 在实际应用中，std::vector&lt;int&gt;是一个典型的例子： 12std::vector&lt;int&gt; v1(10, 20); // 10个20std::vector&lt;int&gt; v2{10, 20}; // 10和20 初始化列表构造 优先考虑nullptr而非0或NULLC++11引入了nullptr，它是一个特殊的类型，可以隐式转换为任意指针类型，但不会转换为整数类型。与0和NULL相比，nullptr不仅更加清晰易懂，而且更适配模板： 123456template&lt;typename FuncType, typename MuxType, typename PtrType&gt;decltype(auto) lockAndCall(FuncType func, MuxType&amp; mutex, PtrType ptr) { // 使用std::lock_guard保证互斥量在函数退出时解锁 std::lock_guard&lt;MuxType&gt; g(mutex); return func(ptr);} 优先考虑别名声明而非typedef首先是别名声明alias declaration在声明函数指针时更加易懂： 12typedef void (*FP)(int, const std::string&amp;); // typedefusing FP = void (*)(int, const std::string&amp;); // 别名声明 更重要的是别名声明可以声明模板别名： 12345template&lt;typename T&gt;using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; // 别名声明MyAllocList&lt;Widget&gt; lw; // 使用别名声明// 等价于std::list&lt;Widget, MyAlloc&lt;Widget&gt;&gt; lw; 如果一定要使用typedef： 123456template&lt;typename T&gt;struct MyAllocList { typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; // typedef};MyAllocList&lt;Widget&gt;::type lw; // 使用typedef 在模板元编程(template metaprogramming, TMP)中，常常会类型修饰的转换： 12345678std::remove_const&lt;T&gt;::type; // C++11 const T -&gt; Tstd::remove_const_t&lt;T&gt;; // C++14std::remove_reference&lt;T&gt;::type; // C++11 T&amp;/T&amp;&amp; -&gt; Tstd::remove_reference_t&lt;T&gt;; // C++14std::add_lvalue_reference&lt;T&gt;::type; // C++11 T -&gt; T&amp;std::add_lvalue_reference_t&lt;T&gt;; // C++14 我们自己要实现两个标准间的转换也只需要使用别名声明(注意要在依赖类型名前加上typename)： 12template&lt;typename T&gt;using remove_const_t = typename remove_const&lt;T&gt;::type; 优先使用限域的enum class而非enum通常来说{}内的声明是限域的，但是enum是个例外： 12enum Color { black, white, red }; // black, white, red在Color的作用域auto white = false; // 错误！white已经被声明 而使用C++11的enum class则不会出现这个问题： 12345enum class Color { black, white, red }; // black, white, red在Color的作用域auto white = false; // 正确！white不在Color的作用域Color c = white; // 错误！white不在作用域中Color c = Color::white; // 正确！auto c = Color::white; // 正确！ 除了防止命名空间污染，enum class也不像enum那样隐式转换，即要使用枚举值必须写明类型，如Color::white。 另外，enum class不仅可以提前声明，还可以指定底层类型： 1enum class Status: std::uint32_t; 但在某些情况下，非限域的enum也是很有用的，比如这个存储用户信息的例子： 1234using UserInfo = std::tuple&lt;std::string, std::string, std::size_t&gt;;enum UserInfoFields { uiName, uiEmail, uiReputation };UserInfo uInfo;auto val = std::get&lt;uiEmail&gt;(uInfo); 用enum class来写会较为繁琐： 123enum class UserInfoFields { uiName, uiEmail, uiReputation };UserInfo uInfo;auto val = std::get&lt;static_cast&lt;std::size_t&gt;(UserInfoFields::uiEmail)&gt;(uInfo); 但是可以使用一个辅助函数来简化： C++11 C++14 123456template&lt;typename E&gt;constexpr typename std::underlying_type&lt;E&gt;::type toUType(E enumerator) noexcept { return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(enumerator);} 12345template&lt;typename E&gt;constexpr autotoUType(E enumerator) noexcept { return static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(enumerator);} 然后就能通过toUType来获取枚举值了： 1auto val = std::get&lt;toUType(UserInfoFields::uiEmail)&gt;(uInfo); 优先考虑delete而非private在C++98中，禁用部分成员函数往往通过将其设为private并且不予定义来实现： C++98的声明12345678template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;class basic_ios : public ios_base {public: // ...private: basic_ios(const basic_ios&amp;); // 不予定义 basic_ios&amp; operator=(const basic_ios&amp;); // 不予定义}; 而在C++11中，可以使用delete来更好地实现： C++11的声明1234567template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;class basic_ios : public ios_base {public: // ... basic_ios(const basic_ios&amp;) = delete; // 标记为public可以获得更好的错误信息 basic_ios&amp; operator=(const basic_ios&amp;) = delete;}; 另外，delete可以用于任何函数： 1234bool isLucky(int number);bool isLucky(char) = delete; // 禁用char参数的isLuckybool isLucky(bool) = delete; // 禁用bool参数的isLuckybool isLucky(double) = delete; // 禁用double和float参数的isLucky delete也可以用于模板函数： 12345678template&lt;typename T&gt;void processPointer(T* ptr);template&lt;&gt;void processPointer&lt;void&gt;(void*) = delete; // 禁用void*参数的processPointertemplate&lt;&gt;void processPointer&lt;char&gt;(char*) = delete; // 禁用char*参数的processPointer 使用override声明重写函数在C++98的重写虚函数规定的基础上，C++11增加了一条规定：函数的引用限定符reference qualifier也必须相同： 1234567891011class Widget {public: virtual void doWork() &amp;; // 只有*this为左值时才能调用 virtual void doWork() &amp;&amp;; // 只有*this为右值时才能调用};Widget makeWidget(); // 工厂函数，返回右值Widget w; // 左值w.doWork(); // 调用Widget::doWork() &amp;makeWidget().doWork(); // 调用Widget::doWork() &amp;&amp; 通过将override放在函数声明后面，可以让编译器检查是否重写了基类的虚函数： 有关引用限定符还可以举一个例子： 1234567891011class Widget {public: using DataType = std::vector&lt;double&gt;; DataType&amp; data() &amp; { return values; } // 仅当*this为左值时调用(返回左值) DataType data() &amp;&amp; { return std::move(values); } // 仅当*this为右值时调用(返回右值)private: DataType values;};auto vals1 = w.data(); // vals1是左值，调用Widget::data() &amp;，拷贝构造auto vals2 = makeWidget().data(); // vals2是右值，调用Widget::data() &amp;&amp;，移动构造","link":"/zh-CN/Effective-Modern-C-2-%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3C/"},{"title":"Effective Modern C++(10) 并发API(1)","text":"优先考虑基于任务而非基于线程基于线程的异步执行如下： 12int doAsyncWork();std::thread t(doAsyncWork); 而基于任务的异步执行如下： 1auto fut = std::async(doAsyncWork); 由此可见基于线程是无法获取返回值的，而基于任务可以使用返回的std::future的get函数获取返回值，从而可以处理各种异常。而基于线程的实现在出现异常时会直接调用std::terminate，即使声明了noexcept也不例外。 基于任务的实现实际上是一种封装，它将线程的调度交给了库的开发者实现。 异步需要指定std::launch::asyncstd::async的默认启动策略实际上是求或的，即下面两者是相同的： 12auto fut1 = std::async(doAsyncWork);auto fut2 = std::async(std::launch::async | std::launch::deferred, doAsyncWork); 这样的实现能够避免资源超频，平衡负载，但同时也有一些需要注意的地方，比如给定一个线程t执行下面的语句： 1auto fut = std::async(f); 无法预测f与t是否并发运行 无法预测f是否执行 也就是说，下面的循环可能永远在运行： 1234567891011using namespace std::literals;void f() { std::this_thread::sleep_for(1s);}auto fut = std::async(f);while (fut.wait_for(100ms) != std::future_status::ready) { // do something} 要修复即要判断f的执行策略： 12345678auto fut = std::async(f);if (fut.wait_for(0s) == std::future_status::deferred) { ...} else { while (fut.wait_for(100ms) != std::future_status::ready) { // do something }} 只要满足以下条件，std::async的默认启动策略就可以使用： 任务不需要和执行get或wait的线程并发执行 读写哪个线程的thread_local变量不会有问题 保证会在std::async返回的future上调用wait或get，或该任务不执行也可行 使用wait_for或wait_until编码时考虑到了延迟状态 如果不满足以上任何条件，就需要指定std::launch::async： 1auto fut = std::async(std::launch::async, f); 我们也可以实现一个异步类： C++11的实现 C++14的简化 12345678template&lt;typename F, typename... Ts&gt;inlinestd::future&lt;typename std::result_of&lt;F(Ts...)&gt;::type&gt;reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params) { return std::async(std::launch::async, std::forward&lt;F&gt;(f), std::forward&lt;Ts&gt;(params)...);} 1234567template&lt;typename F, typename... Ts&gt;inlineauto reallyAsync(F&amp;&amp; f, Ts&amp;&amp;... params) { return std::async(std::launch::async, std::forward&lt;F&gt;(f), std::forward&lt;Ts&gt;(params)...);}","link":"/zh-CN/Effective-Modern-C-10-%E5%B9%B6%E5%8F%91API-1/"},{"title":"Effective Modern C++(3) 移步现代C++(2)","text":"优先考虑const_iterator而非iterator考虑如下的代码： C++98的实现1234std::vector&lt;int&gt; values;...std::vector&lt;int&gt;::iterator it = std::find(values.begin(), values.end(), 1983);values.insert(it, 1998); 这里使用iterator实际上不是一个好的选择，因为这段代码并不改变其指向的内容。使用C++11中的const iterator更为合理： C++11的实现1234std::vector&lt;int&gt; values;...auto it = std::find(values.cbegin(), values.cend(), 1983); // 使用cbegin和cendvalues.insert(it, 1998); C++14中的支持程度更高，加入了cbegin，cend，rbegin，rend，crbegin，crend。 不抛出异常的函数使用noexcept优化！123RetType function(params) noexcept; // 极尽所能优化RetType function(params) throw(); // 较少优化（C++98）RetType function(params); // 较少优化 swapswap函数在STL中大量使用，因此对其使用不抛异常的优化是非常有价值的。有趣的是，标准库的swap是否noexcept有时依赖于用户定义的swap是否noexcept： 数组和std::pair的swap声明123456789template&lt;typename T, size_t N&gt;void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b)));template&lt;typename T1, typename T2&gt;struct pair { ... void swap(pair&amp; p) noexcept(noexcept(swap(first, p.first)) &amp;&amp; noexcept(swap(second, p.second))); ...}; 尽可能使用constexprconstexpr对象constexpr对象是编译期可知的(更准确的说法是翻译期translation)： 123456789int sz; // 非constexprconstexpr auto arraySize1 = sz; // 错误，sz值在编译期未知std::array&lt;int, sz&gt; data1; // 错误，sz值在编译期未知constexpr auto arraySize2 = 10; // 正确，10是常量表达式std::array&lt;int, arraySize2&gt; data2; // 正确，arraySize2是常量表达式const auto arraySize3 = sz; // 正确，arraySize是sz的const复制std::array&lt;int, arraySize3&gt; data3; // 错误，arraySize3的值在编译期未知 constexpr函数对于constexpr函数，如果实参是编译期常量，函数将产出编译期常量；如果实参在运行时才知道，函数就产出运行时值。 整数pow1234567constexprint pow(int base, int exp) noexcept { ...}constexpr auto numConds = 5;std::array&lt;int, pow(3, numConds)&gt; results; // 编译期可知大小 在C++11中，constexpr函数只能有一行return语句： C++11实现整数pow123constexpr int pow(int base, int exp) noexcept { return (exp == 0 ? 1 : base * pow(base, exp - 1));} C++14constexpr函数的限制十分宽松： C++14实现整数pow123456constexpr int pow(int base, int exp) noexcept { auto result = 1; for (itn i = 0; i &lt; exp; ++i) result *= base; return result;} 在C++11中，除了void的类型都可以是字面值类型。下面考虑一个自定义的类型： 123456789101112131415class Point {public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) {} constexpr double xValue() const noexcept { return x; } constexpr double yValue() const noexcept { return y; } void setX(double newX) noexcept { x = newX; } void setX(double newX) noexcept { x = newX; }private: double x, y;} 将构造函数声明为constexpr，则如果传入的参数在编译期可知，那么Point的数据成员也在编译期可知。 在C++14中，const和void的限制被放开，因此上面两个setter函数也能被声明为constexpr。 让const成员函数线程安全使用互斥量mutex考虑一个多项式类： 多项式类求根123456789101112131415161718class Polynomial {public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { if (!rootsAreValid) { // 计算多项式的根 ... rootsAreValid = true; } return rootVals; }private: mutable bool rootsAreValid{false}; mutable RootsType rootVals{};}; 但上述函数并不是线程安全的，可能会出现不同线程读写相同内存的情况。要解决这个问题最简单的办法就是使用互斥量mutex： 多项式类求根(线程安全)1234567891011121314151617181920class Polynomial {public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { std::lock_guard&lt;std::mutex&gt; g(m); // 加锁 if (!rootsAreValid) { // 计算多项式的根 ... rootsAreValid = true; } return rootVals; } // 解锁private: mutable bool rootsAreValid{false}; mutable RootsType rootVals{}; mutable std::mutex m; // 互斥量}; std::atomic某些情况下，互斥量的开销可能过大，这时可以考虑使用std::atomic： 多项式类记录调用次数(线程安全)12345678910111213class Polynomial {public: ... double distanceFromOrigin() const noexcept { ++callCount; // 记录调用次数 ... return std::sqrt((x * x) + (y * y)); }private: mutable std::atomic&lt;unsigned&gt; callCount{0}; // 记录调用次数 double x, y;}; 但要注意std::atomic只适合操作单个变量或者内存位置。 特殊成员函数的生成特殊生成函数指的是C++自己生成的函数。C++98中包括默认构造函数，析构函数，拷贝构造函数，拷贝赋值运算符；C++11中加入了移动构造函数和移动赋值运算符。 C++11新的特殊生成函数123456class Widget {public: ... Widget(Widget&amp;&amp; rhs); // 移动构造函数 Widget&amp; operator=(Widget&amp;&amp; rhs); // 移动赋值运算符}; Rule of Three原则：如果声明了拷贝构造函数、拷贝复制运算符、析构函数中的任意一个，那么就应该声明另外两个。 C++11仅当下面条件成立时才会生成移动操作(当需要时)： 类没有拷贝操作 类没有移动操作 类没有用户定义的析构函数 如果编译器生成的函数行为是正确的，可以使用C++11的=default来显式声明： 1234567class Widget {public: ... ~Widget(); Widget(const Widget&amp;) = default; Widget&amp; operator=(const Widget&amp;) = default;}; 这样的做法在多态基类中很有用： 多态基类1234567891011class Base {public: virtual ~Base() = default; // 使析构函数virtual Base(Base&amp;&amp;) = default; // 支持移动 Base&amp; operator=(Base&amp;&amp;) = default; Base(const Base&amp;) = default; // 支持拷贝 Base&amp; operator=(const Base&amp;) = default; ...};","link":"/zh-CN/Effective-Modern-C-3-%E7%A7%BB%E6%AD%A5%E7%8E%B0%E4%BB%A3C-2/"},{"title":"Effective Modern C++(4) 智能指针(1)","text":"对独占资源使用std::unique_ptr作为一种只可移动类型(move-only type)，std::unique_ptr体现了专有所有权(exclusive ownership)。std::unique_ptr最常见的用法是作为继承层次结构中对象的工厂函数的返回类型。考虑这样的类型： 1234class Investment { ... };class Stock : public Investment { ... };class Bond : public Investment { ... };class RealEstate : public Investment { ... }; Investment继承关系的工厂函数可以这样声明： 12template&lt;typename... Ts&gt;std::unique_ptr&lt;Investment&gt; makeInvestment(Ts&amp;&amp;... params); 调用者在单独的作用域中使用返回的std::unique_ptr： 1234{ auto pInvestment = makeInvestment(...); // 调用工厂函数 ...} // pInvestment被销毁 除了采用默认的delete销毁器，std::unique_ptr还可以采用自定义的销毁器： 12345678910111213141516171819auto delInvmt = [](Investment* pInvestment) { makeLogEntry(pInvestment); // 记录销毁的对象 delete pInvestment; // Investment必须有虚析构函数};template&lt;typename... Ts&gt;std::unique_ptr&lt;Investment, decltype(delInvmt)&gt;makeInvestment(Ts&amp;&amp;... params) { std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt); if (/*一个Stock对象应该被创建*/) { pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个Bond对象应该被创建*/) { pInv.reset(new Bond(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个RealEstate对象应该被创建*/) { pInv.reset(new RealEstate(std::forward&lt;Ts&gt;(params)...)); } return pInv;} 由于原始指针(比如new创建的)赋值给std::unique是无法通过编译的，所以这里使用了reset函数。 C++14中可以推导函数的返回类型，因而可以有更简单的封装： 1234567891011121314151617template&lt;typename... Ts&gt;auto makeInvestment(Ts&amp;&amp;... params) { auto delInvmt = [](Investment* pInvestment) { // 利用无状态函数对象(如lambda) makeLogEntry(pInvestment); // 不影响std::unique_ptr的大小 delete pInvestment; }; std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; pInv(nullptr, delInvmt); if (/*一个Stock对象应该被创建*/) { pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个Bond对象应该被创建*/) { pInv.reset(new Bond(std::forward&lt;Ts&gt;(params)...)); } else if (/*一个RealEstate对象应该被创建*/) { pInv.reset(new RealEstate(std::forward&lt;Ts&gt;(params)...)); } return pInv;} 共享资源使用std::shared_ptrstd::shared_ptr代表着共享所有权，它通过引用计数(reference count)来关联资源并跟踪指向该资源的指针数量。std::shared_ptr在自定义删除器上与std::unique_ptr有所不同： 1234567auto loggingDel = [](Widget *pw) { makeLogEntry(pw); delete pw;};std::unique_ptr&lt;Widget, decltype(loggingDel)&gt; upw(new Widget, loggingDel);std::shared_ptr&lt;Widget&gt; spw(new Widget, loggingDel); // 不同std::shared_ptr可以使用不同的删除器 std::shared_ptr对象在内存中实际是这样的： 控制块的构造遵循以下原则： std::shared_ptr的构造函数会创建一个控制块 从独占指针(std::unique_ptr)构造std::shared_ptr时创建控制块 从原始指针上构造出std::shared_ptr时创建控制块 因此按照以下的声明： 一个错误的做法123auto pw = new Widget;std::shared_ptr&lt;Widget&gt; spw1(pw, loggingDel);std::shared_ptr&lt;Widget&gt; spw2(pw, loggingDel); 这样会使pw被销毁两次！因此应当尽可能使用std::make_shared，如果需要自定义的删除器，应当直接使用new的结果： 合理的做法12std::shared_ptr&lt;Widget&gt; spw1(new Widget, loggingDel);std::shared_ptr&lt;Widget&gt; spw2(spw1); 另一个需要注意的地方是使用this指针作为std::shared_ptr构造函数实参的时候可能导致创建多个控制块： 123456789std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets; // 跟踪已处理的Widgetclass Widget {public: ... void process() { processedWidgets.emplace_back(this); // 创建一个新的控制块 } ...}; 但成员函数外也存在指向该Widget对象的指针，因此应当使用std::enable_shared_from_this： 123456789101112131415class Widget : public std::enable_shared_from_this&lt;Widget&gt; {public: // 完美转发参数给private构造函数的工厂函数 template&lt;typename... Ts&gt; static std::shared_ptr&lt;Widget&gt; create(Ts&amp;&amp;... params) { return std::shared_ptr&lt;Widget&gt;(new Widget(std::forward&lt;Ts&gt;(params)...)); } ... void process() { processedWidgets.emplace_back(shared_from_this()); // 使用已有的控制块 } ...private: ... // 构造函数}; 当std::shared_ptr可能悬空时使用std::weak_ptrstd::weak_ptr是std::shared_ptr的增强，通常从std::shared_ptr上创建，跟踪所指对象(不影响RC)，在悬空时知晓，但不能解引用，也不能测试是否为空值。 1234567auto spw = std::make_shared&lt;Widget&gt;();std::weak_ptr&lt;Widget&gt; wpw(spw); // wpw指向spw所指对象(RC仍为1)spw = nullptr; // RC为0，Widget对象被销毁if (wpw.expired()) { // wpw指向的对象已被销毁 ...} 通常我们期望检查std::weak_ptr是否已经过期，如果没有过期就访问其指向的对象： 12std::shared_ptr&lt;Widget&gt; spw = wpw.lock(); // 如果wpw已过期，spw为空值auto spw2 = wpw.lock(); // 同上 std::weak_ptr的一个常见用法是实现缓存(cache)，比如一个Widget的缓存： 123456789std::shared_ptr&lt;Widget&gt; fastLoadWidget(WidgetID id) { static std::unordered_map&lt;WidgetID, std::weak_ptr&lt;Widget&gt;&gt; cache; // 一个缓存 auto objPtr = cache[id].lock(); // 尝试获取Widget if (!objPtr) { // 如果Widget不在缓存中 objPtr = loadWidget(id); // 从磁盘加载Widget cache[id] = objPtr; // 将Widget添加到缓存中 } return objPtr;} 另一个例子是实现观察者模式(observer pattern)，subject对象维护一个std::weak_ptr的集合，每个weak_ptr指向一个observer对象，当subject对象改变时，它会通知所有的observer对象。","link":"/zh-CN/Effective-Modern-C-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1/"},{"title":"Effective Modern C++(5) 智能指针(2)","text":"优先考虑使用std::make_unique和std::make_shared而非直接使用new少打字，效率高！1234auto upw1(std::make_unique&lt;Widget&gt;()); // 使用makestd::unique_ptr&lt;Widget&gt; upw2(new Widget); // 不使用make，两次内存分配auto spw1(std::make_shared&lt;Widget&gt;()); // 使用makestd::shared_ptr&lt;Widget&gt; spw2(new Widget); // 不使用make，两次内存分配 异常安全考虑一个函数按照某种优先级处理Widget： 1234void processWidget(std::shared_ptr&lt;Widget&gt; spw, int priority);// 调用processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), computePriority()); 如果采用上面的方法调用，由于编译器的优化，无论何种顺序都可能由于异常退出产生内存泄漏！而采用下面的调用就能解决这个问题： 1processWidget(std::make_shared&lt;Widget&gt;(), computePriority()); make的限制不能使用自定义删除器12345auto widgetDeleter = [](Widget* pw) { ... };std::unique_ptr&lt;Widget, decltype(widgetDeleter)&gt; upw(new Widget, widgetDeleter);std::shared_ptr&lt;Widget, decltype(widgetDeleter)&gt; spw(new Widget, widgetDeleter); 语法细节make函数的初始化默认是使用圆括号，也就是说： 12auto upv = std::make_unique&lt;std::vector&lt;int&gt;&gt;(10, 20);auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(10, 20); 上面这两个调用都创建了10个元素、每个值为20的std::vector。要使用花括号初始化，有一个变通的办法： 12auto initList = { 10, 20 };auto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(initList); 自定义内存管理对象函数如果重载了operator new，operator delete就不应该使用make函数，因为make函数会忽略这些重载。 大对象如果对象类型非常大，而且销毁最后一个std::shared_ptr和销毁最后一个std::weak_ptr之间的时间很长，那么在销毁对象和释放它所占用的内存之间可能会出现延迟。 使用Pimpl惯用法时，将特殊成员函数的定义放到实现文件中Pimpl(pointer to implementation)惯用法通过将类数据成员替换成一个指向包含具体实现的类(或结构体)的指针，并将放在主类(primary class)的数据成员们移动到实现类(implement class)去。考虑这样一个原始的类； 123456789class Widget { // 定义在头文件&quot;widget.h&quot;中public: ~Widget(); ...private: std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; // Gadget是一个用户自定义类}; C++98中，我们可以这样实现Pinpl惯用法： widget.h widget.cpp 123456789class Widget {public: Widget(); ~Widget(); ...private: struct Impl; // 声明一个实现结构体 Impl *pImpl;}; 123456789101112131415#include &quot;widget.h&quot;#include &quot;gadget.h&quot;#include &lt;string&gt;#include &lt;vector&gt;struct Widget::Impl { // 含有之前在Widget中的数据成员 std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3;};Widget::Widget(): pImpl(new Impl) {}Widget::~Widget() { delete pImpl; } C++11中，我们可以使用std::unique_ptr来实现： widget.h widget.cpp 123456789class Widget {public: Widget(); ~Widget(); ...private: struct Impl; // 声明一个实现结构体 std::unique_ptr&lt;Impl&gt; pImpl;}; 123456789101112131415#include &quot;widget.h&quot;#include &quot;gadget.h&quot;#include &lt;string&gt;#include &lt;vector&gt;struct Widget::Impl { // 含有之前在Widget中的数据成员 std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3;};Widget::Widget(): pImpl(std::make_unique&lt;Impl&gt;()) {}Widget::~Widget() = default; 当然也可以加上移动构造函数和移动赋值运算符，但和析构函数一样需要将定义放在实现文件中： widget.h widget.cpp 1234567891011class Widget {public: Widget(); ~Widget(); Widget(Widget&amp;&amp; rhs); Widget&amp; operator=(Widget&amp;&amp; rhs); ...private: struct Impl; // 声明一个实现结构体 std::unique_ptr&lt;Impl&gt; pImpl;}; 123456789101112131415161718#include &quot;widget.h&quot;#include &quot;gadget.h&quot;#include &lt;string&gt;#include &lt;vector&gt;struct Widget::Impl { // 含有之前在Widget中的数据成员 std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3;};Widget::Widget(): pImpl(std::make_unique&lt;Impl&gt;()) {}Widget::~Widget() = default;Widget::Widget(Widget&amp;&amp; rhs) = default;Widget&amp; Widget::operator=(Widget&amp;&amp; rhs) = default; 但是如果使用了std::shared_ptr，本节内容就不适应了。","link":"/zh-CN/Effective-Modern-C-5-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-2/"},{"title":"Effective Modern C++(6) 右值引用、移动、转发(1)","text":"理解std::move和std::forwardstd::move和std::forward实际上只是执行转换(cast)的函数，并不会移动或转发任何东西。 std::move具体来说，我们可以给出一个std::move的示例实现： C++11的接近标准的实现 C++14的更简洁实现 1234567template&lt;typename T&gt; // 在std命名空间中定义typename std::remove_reference&lt;T&gt;::type&amp;&amp;move(T&amp;&amp; param){ using ReturnType = typename std::remove_reference&lt;T&gt;::type&amp;&amp;; return static_cast&lt;ReturnType&gt;(param);} 123456template&lt;typename T&gt; // 在std命名空间中定义decltype(auto) move(T&amp;&amp; param){ using ReturnType = std::remove_reference_t&lt;T&gt;&amp;&amp;; return static_cast&lt;ReturnType&gt;(param);} 从实际作用上说，std::move可能名字换成rvalue_cast更好。 隐蔽的“错误”考虑这样一个注解类： 12345678class Annotation {public: explicit Annotation(const std::string text) : value(std::move(text)) {} ...private: std::string value;}; 这段代码的运行没有任何问题，但text并不是被移动到value，而是被拷贝。这涉及std::string的构造函数： 123456class string { // 实际上是std::basic_string&lt;char&gt;的类型别名public: string(const string&amp; rhs); // 拷贝构造函数 string(string&amp;&amp; rhs); // 移动构造函数 ...}; std::move(text)返回的是一个const std::string的右值引用，而std::string的移动构造函数接受的是一个std::string的右值引用，因此编译器会选择拷贝构造函数。 使用移动的建议根据上面这个反例，我们可以总结出以下两点建议： 希望能移动对象时，不要声明为const。 std::move并不保证转换后的对象可以移动，而只是得到一个右值。 std::forwardstd::forward只有在满足一定条件下才执行转换。考虑一个典型的用法： 12345678910void process(const Widget&amp; lvalArg);void process(Widget&amp;&amp; rvalArg);template&lt;typename T&gt;void logAndProcess(T&amp;&amp; param) { auto now = std::chrono::system_clock::now(); makeLogEntry(&quot;Calling 'process'&quot;, now); process(std::forward&lt;T&gt;(param));} 这样调用的话： 123Widget w;logAndProcess(w); // 调用process(const Widget&amp;)logAndProcess(std::move(w)); // 调用process(Widget&amp;&amp;) 即std::forward实参用右值初始化时，转换为一个右值。 通用引用和右值引用在两种情况下会出现通用引用： 1234template&lt;typename T&gt;void f(T&amp;&amp; param);auto&amp;&amp; var1 = var2; 这两种情况的共同之处就是存在类型推导。 模板推导注意引用声明的形式必须是T&amp;&amp;，也就是说： 12345template&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param); // 右值引用template&lt;typename T&gt;void f(const T&amp;&amp; param); // 右值引用 但是出现T&amp;&amp;并不一定是通用引用，这是由于在模板内部并不一定保证一定发生类型推导： 1234567template&lt;class T, class Allocator = allocator&lt;T&gt;&gt; //来自C++标准class vector {public: ... void push_back(T&amp;&amp; x); ...}; 但push_back在一个特定的vector实例之前并不可能存在，而在实例化之和： 123456789std::vector&lt;Widget&gt; v;// 实例化后class vector&lt;Widget, allocator&lt;Widget&gt;&gt; {public: ... void push_back(Widget&amp;&amp; x); ...}; 而另一个成员函数： 12345678template&lt;class T, class Allocator = allocator&lt;T&gt;&gt;class vector {public: ... template&lt;class... Args&gt; // Args是一个模板参数包 void emplace_back(Args&amp;&amp;... args); ...}; 这里的Args&amp;&amp;就是通用引用了。 autoauto&amp;&amp;在C++14中出现的更多，因为C++14中lambda表达式可以声明auto&amp;&amp;形参： 123456auto timeFuncInvocation = [](auto&amp;&amp; func, auto&amp;&amp;... params) { start timer; std::forward&lt;decltype(func)&gt;(func)( std::forward&lt;decltype(params)&gt;(params)...); stop timer and record elapsed time;}; 右值引用使用std::move，通用引用使用std::forward在右值引用上使用std::forward容易出现错误，而如果在通用引用上使用std::move则可能意外改变左值： 12345678910111213141516class Widget {public: template&lt;typename T&gt; void setName(T&amp;&amp; newName) { name = std::move(newName); // 绝对不要这样写！ }private: std::string name; std::shared_ptr&lt;SomeDataStructure&gt; p;};std::string getWidgetName(); // 工厂函数Widget w;auto n = getWidgetName();w.setName(n); // n的值未知了！ 倘若通过重载分别实现左值和右值的函数，不仅源代码较长、运行时效率较低，而且可扩展性也较差。尤其是涉及任意参数的情况。 按值返回按值返回的函数使用std::move或者std::forward也能提高效率，以矩阵的加法为例： 123456Matrixoperator+(Matrix&amp;&amp; lhs, const Matrix&amp; rhs){ lhs += rhs; return std::move(lhs);} 返回值优化但对于局部变量，情况有所不同： 12345Widget makeWidget() { Widget w; ... return std::move(w); // 不要这样做！} 标准委员会早就意识到makeWidget的“拷贝”版本可以避免复制局部变量w的需要，通过在分配给函数返回值的内存中直接构造w，这就是返回值优化(return value optimization，RVO)。这需要满足： 局部对象和返回类型相同。 局部对象就是要返回的东西。 避免在通用引用上重载首先考虑这样一个函数： 12345678910111213std::multiset&lt;std::string&gt; names;template&lt;typename T&gt;void logAndAdd(T&amp;&amp; name) { auto now = std::chrono::system_clock::now(); makeLogEntry(&quot;logAndAdd&quot;, name, now); names.emplace(std::forward&lt;T&gt;(name));}std::string petName(&quot;Darla&quot;);logAndAdd(petName); // 传递左值logAndAdd(std::string(&quot;Persephone&quot;)); // 传递右值logAndAdd(&quot;Patty Dog&quot;); // 传递字符串字面量 以上代码能够有效率地工作，但是倘若我们要再加入功能： 123456789std::string nameFromIdx(int idx); // 从索引中获取名字void logAndAdd(int idx) { // 新的重载 auto now = std::chrono::system_clock::now(); makeLogEntry(&quot;logAndAdd&quot;, nameFromIdx(idx), now); names.emplace(nameFromIdx(idx));}logAndAdd(42); // 调用logAndAdd(int) 但如果这样调用： 12short nameIdx;logAndAdd(nameIdx); // 错误！ 这是因为通过类型推导，该调用会选择通用引用，因此调用会出错！通用引用贪婪性的另一个例子是完美转发构造函数： 12345678910class Person {public: template&lt;typename T&gt; explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {}private: std::string name;}; 这样就会出现与上面类似的问题。另一个问题是编译器会生成拷贝和移动构造函数： 12345678910class Person {public: template&lt;typename T&gt; explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {} Person(const Person&amp; rhs) : name(rhs.name) {} // 拷贝构造函数 Person(Person&amp;&amp; rhs) : name(std::move(rhs.name)) {} // 移动构造函数}; 而导致了下面这种调用会出现问题： 12Person p(&quot;Nancy&quot;);auto cloneOfP(p); // 从p创建新的Person，无法通过编译！ 由于没有const，编译器会使用完美转发构造，这不符合我们的需要。当涉及继承关系时，情况会更加复杂。因此，尽量不要在通用引用上重载。如果需要可转发大多数实参类型的函数，而对于某些实参类型又要特殊处理，请看下篇。","link":"/zh-CN/Effective-Modern-C-6-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E8%BD%AC%E5%8F%91-1/"},{"title":"Effective Modern C++(7) 右值引用、移动、转发(2)","text":"通用引用重载的替代在上一节的末尾，我们谈到了通用引用重载出现的问题。在这里我们将讨论一些替代方案。 放弃通用引用以上一节的logAndAdd为例，我们可以将其分为logAndAddName和logAndAddNameIdx两个函数。但这种方法无法适用于通用引用构造函数的情况，因为此时的名字是固定的。 传递const T&amp;这种方法实际上就回退到了C++98。但缺点是效率不高。 传值在知道要拷贝时就按值传递，后续我们会再讨论这个建议。 123456789101112class Person {public: explicit Person(std::string n) // 代替T&amp;&amp;构造函数 : name(std::move(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {} ...private: std::string name;}; 使用tag dispatch上述方法都不支持完美转发，要实现完美转发只能采用通用引用。如果需要重载，我们可以将通用引用作为包含在其它非通用引用的形参列表的一部分，这就是tag dispatch。 12345678910111213141516171819template&lt;typename T&gt;void logAndAdd(T&amp;&amp; name){ logAndAddImpl(std::forward&lt;T&gt;(name), std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;());}template&lt;typename T&gt;void logAndAddImpl(T&amp;&amp; name, std::false_type){ auto now = std::chrono::system_clock::now(); log(now, &quot;logAndAdd&quot;); names.emplace_back(std::forward&lt;T&gt;(name));}void logAndAddImpl(int idx, std::true_type){ logAndAdd(nameFromIdx(idx));} 约束使用通用引用的模板tag dispatch仍然在构造函数上存在问题，我们需要进一步地确定允许使用通用引用模板的条件。我们需要std::enable_if。下面直接给出完整的实现： 123456789101112131415161718class Person {public: template&lt;typename T, typename = std::enable_if_t&lt; !std::is_base_of&lt;Person, std::decay_t&lt;T&gt;&gt;::value // 允许基类调用 &amp;&amp; !std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;::value &gt; &gt; explicit Person(T&amp;&amp; n) // 对于std::string和能够转化为std::string的实参 : name(std::forward&lt;T&gt;(n)) {} explicit Person(int idx) : name(nameFromIdx(idx)) {} ...private: std::string name;}; 折中完美转发更有效率，但也有缺点，后文也会探索完美转发失败的例子。另一个问题是客户传递无效参数时错误消息的可理解性。比如： 1Person p(u&quot;Konrad Zuse&quot;); // u&quot;Konrad Zuse&quot;是const char16_t类型字符串类型 在Person中，我们知道完美转发函数的通用引用形参要作为std::string的初始化器，因此可以使用static_assert： 123456789101112131415161718class Person {public: template&lt; typename T, typename = std::enable_if_t&lt; !std::is_base_of&lt;Person, std::decay_t&lt;T&gt;&gt;::value &amp;&amp; !std::is_integral&lt;std::remove_reference_t&lt;T&gt;&gt;::value &gt; &gt; explicit Person(T&amp;&amp; n) : name(std::forward&lt;T&gt;(n)) { static_assert( std::is_constructible&lt;std::string, T&gt;::value, &quot;Parameter n can't be used to construct a std::string&quot; ); ... }}; 理解引用折叠首先，我们知道在C++中引用的引用是非法的： 12int x;auto&amp; &amp; rx = x; // 错误！ 但将左值传给通用引用的模板函数时： 1234template&lt;typename T&gt;void func(T&amp;&amp; param);func(w); T的推导类型初始化模板会得到： 1void func(Widget&amp; &amp;&amp; param); // T为Widget&amp; 最后转化为： 1void func(Widget&amp; param); 这就是引用折叠(reference collapsing)，尽管不能声明引用的引用，但编译器可以生成引用的引用。两个引用中任意引用为左值，则最后折叠为左值引用，即引用折叠的规则如下： T&amp; &amp; -&gt; T&amp; T&amp; &amp;&amp; -&gt; T&amp; T&amp;&amp; &amp; -&gt; T&amp; T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp; 依照这个规则，我们可以给出std::forward的实现： C++11版本 C++14版本 1234template&lt;typename T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp; param) { return static_cast&lt;T&amp;&amp;&gt;(param);} 1234template&lt;typename T&gt;T&amp;&amp; forward(std::remove_reference_t&lt;T&gt;&amp; param) { return static_cast&lt;T&amp;&amp;&gt;(param);} 同样的推导也会发生在auto、using/typedef别名声明、delctype中。 移动操作的缺点在某些情况下，移动操作并没有想象中那么优秀。 std::array考虑std::array和std::vector。后者将具体数据存储在堆内存，而本身只保存了指向堆内存中容器内容的指针，因而其移动是可以以常数时间运行的。但std::array没有这种指针的实现，其数据就存储在对象中，因而其移动是以线性时间进行的。 std::string许多字符串的实现采用了小字符串优化(small string optimization，SSO)，“小”字符串存储在std::string的缓冲区而不是堆内存，在这种情况下移动并不比复制更快。 noexcept进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为noexcept，此时移动不可用。 在通用代码中，需要假定移动操作不存在，成本高，未被使用；但在已知类型或者支持移动语义的代码中，就不需要这种假设。 完美转发失败的情况12345678910template&lt;typename T&gt;void fwd(T&amp;&amp; param) { f(std::forward&lt;T&gt;(param));}// 可变形式template&lt;typename... Ts&gt;void fwd(Ts&amp;&amp;... params) { f(std::forward&lt;Ts&gt;(params)...);} 花括号初始化器假定f这样声明： 1void f(const std::vector&lt;int&gt;&amp; v); 此时，用花括号初始化调用f能够通过编译： 1f({1, 2, 3}); // 可以！隐式转换为std::vector&lt;int&gt; 但相同的列表初始化传给fwd则不能编译： 1fwd({1, 2, 3}); // 错误！无法编译 这是由于此时是将推导传入给fwd的实参类型，然后比较推导后的实参类型和f的形参声明类型。一种解决方法是： 12auto il = {1, 2, 3};fwd(il); // 可以！ 0和NULL作为空指针这种情况大可以通过使用nullptr避免。 仅有声明的static const数据成员通常来说static const数据成员在类中是无需定义的，因为编译器会对此类成员实行常量传播(cosnt propagation)。考虑以下代码： 12345678class Widget {public: static const std::size_t MinVals = 28; // MinVals的声明 ...};... // 没有MinVals的定义std::vector&lt;int&gt; widgetData;widgetData.reserve(Widget::MinVals); 以上代码并没有问题，因为编译器会将28放入所有提到MinVals的位置来补充缺少的定义。但如果要使用MinVals的地址(比如创建了指向MinVals的指针)，则上述代码在链接时会出错。同样的，考虑f这样的声明： 1void f(std::size_t val); 使用MinVals直接调用f是可以的： 1f(Widget::MinVals); // 可以，即为f(28) 但是通过fwd调用f就会出错： 1fwd(Widget::MinVals); // 错误！不应该链接 这是因为引用在编译器生成的代码中通常被视为指针，所以必须要有内存可以指向。因此需要给static const提供一个定义： Widget.cpp1const std::size_t Widget::MinVals; // 不要初始化两次！ 重载函数名和模板名考虑这样的f： 12void f(int (*pf)(int)); // pf = &quot;process function&quot;void f(int pf(int)); // 与上述定义相同 假设我们有重载函数： 12int processVal(int value);int processVal(int value, int priority); 我们可以这样调用： 1f(processVal); // 可以 但是fwd作为一个函数模板，没有其它接受的类型信息，所以无法判断哪个函数被传递： 1fwd(processVal); // 错误！哪个processVal？ 在函数模板中也会出现同样的问题： 123456template&lt;typename T&gt;T workOnVal(T param) { ...}fwd(workOnVal); // 错误！哪个workOnVal实例？ 处理这种情况可以通过以下办法： 12345using ProcessFuncType = int (*)(int);ProcessFuncType processValPtr = processVal;fwd(processValPtr);fwd(static_cast&lt;ProcessFuncType&gt;(workOnVal)); 当然这要求知道转发的函数指针类型。 位域以IPv4的头部模型为例： 12345678struct IPv4Header { std::uint32_t version:4, IHL:4, DSCP:6, ECN:2, totalLength:16; ...}; 像这样声明f： 12345void f(std::size_t sz);IPv4Header h;...f(h.totalLength); // 可以 但此时无法直接转发： 1fwd(h.totalLength); // 错误！ 这是由于C++标准不允许non-const引用绑定到位域，因此只能通过创建副本来实现转发： 12auto length = static_cast&lt;std::uint16_t&gt;(h.totalLength);fwd(length); // 转发副本","link":"/zh-CN/Effective-Modern-C-7-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E8%BD%AC%E5%8F%91-2/"},{"title":"Effective Modern C++(8) lambda表达式(1)","text":"避免使用默认捕获模式使用默认按引用捕获的问题使用默认按引用捕获可能会导致悬空引用(dangling reference)。例如： 123456789101112using FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;FilterContainer filters; // 过滤函数void addDivisorFilter() { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto divisor = computeDivisor(calc1, calc2); filters.emplace_back( [&amp;](int value) { return value % divisor == 0; } );} 这里对局部变量divisor进行了引用，因此在addDivisorFilter函数结束后，divisor就会被销毁，而filters中的函数对象仍然会引用它，这就导致了悬空引用。如果写成显式捕获，就更容易提醒注意变量生命周期的问题： 123filters.emplace_back( [&amp;divisor](int value) { return value % divisor == 0; }); 这样能更清楚地提醒我们确保divisor的生命周期至少跟filters一样长。有些时候我们会认为没有悬空引用的危险： C++11的例子 C++14的例子 12345678910111213141516171819template&lt;typename C&gt;void workWithContainer(const C&amp; container) { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto divisor = computeDivisor(calc1, calc2); using ContElemType = typename C::value_type; using std::begin; using std::end; if (std::all_of(begin(container), end(container), [&amp;](const ContElemType&amp; value) { return value % divisor == 0; }) ) { ... } else { ... }} 123456789101112131415template&lt;typename C&gt;void workWithContainer(const C&amp; container) { auto calc1 = computeSomeValue1(); auto calc2 = computeSomeValue2(); auto divisor = computeDivisor(calc1, calc2); if (std::all_of(begin(container), end(container), [&amp;](const auto&amp; value) { return value % divisor == 0; }) ) { ... } else { ... }} 这的确是安全的，但这种安全是不确定的。一个看起来可行的解决方法是将divisor按值捕获： 123filters.emplace_back( [=](int value) { return value % divisor == 0; }); 这可以满足本例的要求，但是并不能完全解决悬空引用的问题。 使用默认按值引用的问题悬空引用默认按值捕获也可能导致悬空引用，比如按值捕获了一个指针，将指针拷贝到lambda对应的闭包中，但在lambda外可能会delete这个指针。尽管有智能指针，但在现代C++中仍然存在隐蔽的问题。考虑这样的类： 12345678910111213class Widget {public: … //构造函数等 void addFilter() const; //向filters添加条目private: int divisor; //在Widget的过滤器使用};void Widget::addFilter() const { filters.emplace_back( [=](int value) { return value % divisor == 0; } );} 事实上这段代码不会按照想象的那样进行，因为捕获只能应用于lambda被创建时所在作用域里的non-static局部变量(包括形参)。实际上这里隐式地使用了一个原始指针this，因此真正被捕获的是Widget的this指针： 12345678void Widget::addFilter() const { auto currentObjectPtr = this; filters.emplace_back( [currentObjectPtr](int value) { return value % currentObjectPtr-&gt;divisor == 0; } );} 类似于这种情况，使用只能指针也可能出现错误： 12345678using FilterContainer = std::vector&lt;std::function&lt;bool(int)&gt;&gt;;FilterContainer filters;void doSomeWork() { auto pw = std::make_unique&lt;Widget&gt;(); pw-&gt;addFilter(); ...} 这里pw是一个智能指针，但是Widget的this指针被捕获了，因此pw在doSomeWork函数结束后就会被销毁，而filters中的函数对象仍然会引用它，这就导致了悬空引用。这个问题可以通过捕获数据的局部副本来解决： 123456void Widget::addFilter() const { auto divisorCopy = divisor; filters.emplace_back( [divicorCopy](int value) { return value % divisorCopy == 0; } );} 在C++14中，更好的方式是使用通用的捕获： 12345void Widget::addFilter() const { filters.emplace_back( [divisor = divisor](int value) { return value % divisor == 0; } );} 静态存储生命周期被声明为static的对象不能被捕获，比如： 123456789void addDivisorFilter() { static auto calc1 = computeSomeValue1(); static auto calc2 = computeSomeValue2(); static auto divisor = computeDivisor(calc1, calc2); filters.emplace_back( [=](int value) { return value % divisor == 0; } ); ++divisor;} 这里的lambda实际是通过引用捕获了divisor。 使用初始化捕获来移动对象到闭包中C++14使用初始化捕获即通用lambda捕获(generalized lambda capture)将std::unique_ptr移动到闭包中的方法如下： 123456789101112131415class Widget {public: … bool isValidated() const; bool isProcessed() const; bool isArchived() const;private: ...};auto pw = std::make_unique&lt;Widget&gt;();auto func = [pw = std::move(pw)] { return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();}; 这里=左侧的作用域是闭包类，而右侧的作用域和lambda定义所在的作用域相同。如果不需要另外的操作也可以这样写： 123auto func = [pw = std::make_unique&lt;Widget&gt;()] { return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived();}; C++11C++11没有初始化捕获，如果不写lambda，上面的内容可以这样实现： 123456789101112class IsValAndArch {public: using DataType = std::unique_ptr&lt;Widget&gt;; explicit IsValAndArch(DataType&amp;&amp; ptr) : pw(std::move(ptr)) {} bool operator()() const { return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); }private: DataType pw;};auto func = IsValAndArch(std::make_unique&lt;Widget&gt;()); 如果坚持使用lambda，可以通过std::bind来实现： 123456auto func = std::bind( [](const std::unique_ptr&lt;Widget&gt;&amp; pw) { return pw-&gt;isValidated() &amp;&amp; pw-&gt;isArchived(); }, std::make_unique&lt;Widget&gt;() );","link":"/zh-CN/Effective-Modern-C-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-1/"},{"title":"icarus的一些用法","text":"本文引自https://blog.geektime.club/posts/8917 自定义效果突出提示栏 谷歌网址为www.google.com 本文同时提供如下语言的翻译：English 文章内容有误？请点击此处提交修改。 第一种-页面内提示123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-circle-info mr-2&quot;&gt;&lt;/i&gt;谷歌网址为&lt;a href=&quot;https://www.google.com&quot;&gt;www.google.com&lt;/a&gt; &lt;/div&gt;&lt;/article&gt; 下面这种方式实际实现的是站内的跳转，因此需要使用post_path变量。 第二种-站内跳转123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;本文同时提供如下语言的翻译：&lt;a href=&quot;&quot;&gt;English&lt;/a&gt; &lt;/div&gt;&lt;/article&gt; 第三种与第一种是类似的。 第三种 >folded123456&lt;article class=&quot;message message-immersive is-warning&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？请点击&lt;a href=&quot;https://github.com/tinaaaaa42&quot;&gt;此处&lt;/a&gt;提交修改。 &lt;/div&gt;&lt;/article&gt; 摘要要实现文章的摘要内容只显示在首页而不显示在正文，有以下两种办法： Front-matter可以将文章的摘要写在 md 文件开头的front-matter信息中： 文章xxx.md123456---......excerpt: 这里是摘要---这里是正文 Bulma也可以采用在正文中使用Bulma搭配 HTML 标签: 文章xxx.md1234567891011这里的内容会出现在简介和正文&lt;div class=&quot;post-summary&quot;&gt;这里的内容只会出现在简介&lt;/div&gt;&lt;!--more--&gt;&lt;style type=&quot;text/css&quot;&gt; .post-summary{ display:none; }&lt;/style&gt; 页内标签页页内标签页可以实现代码块的平行显示，即只会显示当前活跃的标签内容，比如icarus官网上的这个效果： 从源码安装 使用 从 Github 仓库安装… 使用 NPM 安装为 node 包… 具体实现代码如下： 页内标签页语法定义123456789101112131415{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签id&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签id&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} tabs 第一页 第二页 这是small标签页容器的第一页 这是small标签页容器的第二页 第一页 第二页 这是默认标签页容器的第一页 这是默认标签页容器的第二页 第一页 第二页 这是medium标签页容器的第一页 这是medium标签页容器的第二页 第一页 第二页 这是large标签页容器的第一页 这是large标签页容器的第二页 align 第一页 第二页 这是默认标签页容器的第一页 这是默认标签页容器的第二页 第一页 第二页 这是centered标签页容器的第一页 这是centered标签页容器的第二页 第一页 第二页 这是right标签页容器的第一页 这是right标签页容器的第二页 第一页 第二页 这是fullwidth标签页容器的第一页 这是fullwidth标签页容器的第二页 style 第一页 第二页 这是boxed标签页容器的第一页 这是boxed标签页容器的第二页 第一页 第二页 这是toggle标签页容器的第一页 这是toggle标签页容器的第二页 第一页 第二页 这是toggle-rounded标签页容器的第一页 这是toggle-rounded标签页容器的第二页 彩色提示消息带颜色的消息提示能使信息更加醒目，其语法格式如下： 彩色消息提示语法定义123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %}&lt;消息内容&gt;{% endmessage %} color default 这是默认颜色的消息块 dark 这是dark颜色的消息块 primary 这是primary颜色的消息块 info 这是info颜色的消息块 success 这是success颜色的消息块 warning 这是warning颜色的消息块 danger 这是danger颜色的消息块 size small 这是small大小的消息块 default 这是default大小的消息块 medium 这是medium大小的消息块 large 这是large大小的消息块 icon Github图标消息块 这是&quot;icon:fa-brands fa-github&quot;图标的消息块 Nodejs图标消息块 这是&quot;icon:fa-brands fa-node-js&quot;图标的消息块 title 这是没有title的消息块 Hexo 内置专用标签插件引用块123{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %} 代码块123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} iframe1{% iframe url [width] [height] %} image1{% img [class names] /path/to/image [width] [height] '&quot;title text&quot; &quot;alt text&quot;' %} link1{% link text url [external] [title] %} youtube1234{% youtube video_id [type] [cookie] %}// [type]：默认为空，可选 playlist (播放列表)// [cookie]: 默认为true，可选false 一个例子：","link":"/zh-CN/icarus%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"},{"title":"Effective Modern C++(9) lambda表达式(2)","text":"对auto&amp;&amp;形参使用decltype来转发泛型lambda(generic lambdas)只需要这样写： 1234auto f = [](auto&amp;&amp;... param) { return func(normalize(std::forward&lt;decltype(param)&gt;(param)...)); }; 优先考虑lambda而不是std::bindlambda易读性先给出这些定义； 12345using Time = std::chrono::steady_clock::time_point;enum class Sound { Beep, Siren, Whistle };using Duration = std::chrono::steady_clock::duration;void setAlarm(Time t, Sound s, Duration d); 如果要设置一个定时警报器，使用lambda就只需要这样写： C++11的实现 C++14的简化 1234567auto setSoundL = [](Sound s) { using namespace std::chrono; setAlarm(steady_clock::now() + hours(1), s, seconds(30)); }; 12345678auto setSoundL = [](Sound s) { using namespace std::chrono; using namespace std::literals; // 使用C++14的后缀 setAlarm(steady_clock::now() + 1h, s, 30s); }; 而使用std::bind则需要这样写： 12345678using namespace std::chrono;using namespace std::literals;using namespace std::placeholders;auto setSoundB = std::bind(setAlarm, steady_clock::now() + 1h, _1, 30s); 事实上，这样写并不正确，这里实现的功能实际上是在调用std::bind后一个小时发出声音，而不是在调用setAlarm后一个小时发出声音。正确的写法应该是这样： 123456auto setSoundB = std::bind(setAlarm, std::bind(std::plus&lt;&gt;(), // C++14省略标准运算符模板参数 steady_clock::now(), 1h), _1, 30s); 重载的问题假定上述的setAlarm函数有一个重载版本： 12enum class Volume { Normal, Loud, LoudPlusPlus };void setAlarm(Time t, Sound s, Duration d, Volume v); 此时lambda的写法不需要做任何改动，而std::bind则需要强制转换类型： 12345678using SetAlarmType = void (*)(Time, Sound, Duration, Volume);auto setSoundB = std::bind(static_cast&lt;SetAlarmType&gt;(setAlarm), std::bind(std::plus&lt;&gt;(), steady_clock::now(), 1h), _1, 30s); 即使std::bind实现了这样的功能，由于内联的优化，lambda的性能也会更好。 多态函数对象使用std::bind的场景由于bind对象上的函数调用运算符使用完美转发，所以它可以接收任何类型的实参，比如这个类： 1234567class PolyWidget {public: template&lt;typename T&gt; void operator()(const T&amp; param) const { ... }}; std::bind可以这样绑定一个PolyWidget对象： 12PolyWidget pw;auto boundPW = std::bind(pw, _1); 这样boundPW就可以接收任何类型的实参了。 123boundPW(1930); // 调用PolyWidget::operator()&lt;int&gt;(int)boundPW(&quot;hello&quot;); // 调用PolyWidget::operator()&lt;const char*&gt;(const char*)boundPW(nullptr); 但在C++14中，lambda也可以实现这样的功能： 1auto boundPW = [pw](const auto&amp; param) { pw(param); };","link":"/zh-CN/Effective-Modern-C-9-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-2/"},{"title":"我的neovim配置","text":"我的 neovim 配置基于油管上的这个视频，非常细致的老哥！ 在这一篇记录中不会涉及很多原理，基本用于个人的 cheat sheet。 Basic File Structure123456789101112131415~/.config/|__ nvim/ |__ init.lua |__ lua/ |__ young/ |__ core/ | |__ colorscheme.lua | |__ options.lua | |__ keymaps.lua |__ plugins/ | |__ lualine.lua | |__ telescope.lua | |__ nvim-tree.lua | |__ .... |__ plugins-setup.lua 基本 options 配置这部分内容在文件中比较容易看懂，也容易修改，不做赘述。 基本 keymaps 设置leader-key为空格 INSERT模式下按jk等同于&lt;ESC&gt;，即返回NORMAL模式 查找后通过空格+nh 跳转到特定位置并取消高亮 NORMAL模式下通过x删除不复制进 Clipboard NORMAL模式下通过空格+/-对值进行递增/递减 split windows(NORMAL模式) 空格+sv 生成竖直窗口 空格+sh 生成水平窗口 空格+se 使窗口等大 空格+sx 关闭当前窗口 tabs(NORMAL模式) 空格+to 打开新的 tab 空格+tx 关闭当前 tab 空格+tn 到下一个 tab 空格+tp 到前一个 tab Plugins使用Packer作为插件管理器，基本按照文档完成plugins-setup.lua文件的框架。并在init.lua文件最上方加入: 1require(&quot;young.plugins-setup&quot;) 配色plugins-setup.lua1use(&quot;bluz71/vim-nightfly-guicolors&quot;) 并在colorscheme.lua文件中指定。 Navigatorplugins-setup.lua1use(&quot;christoomey/vim-tmux-navigator&quot;) 通过Ctrl+h/j/k/l实现窗口间的移动 Maximizerplugins-setup.lua1use(&quot;szw/vim-maximizer&quot;) 在keymaps.lua中设置空格+sm 将当前窗口最大化或恢复 Essentialplugins-setup.lua12use(&quot;tpope/vim-surround&quot;)use(&quot;vim-scripts/ReplaceWithRegister&quot;) ys+w+” 在该单词两边加双引号 ds+” 去掉两边的双引号 cs+”+’ 将两边的双引号改为单引号 yw 复制当前词，grw 替换为复制的词 Commentplugins-setup.lua1use(&quot;numToStr/Comment.nvim&quot;) 在plugins文件夹中创建comment.lua，完成 setup 后在init.lua中 require 通过 gc+指定内容进行注释或者取消注释，如 gcc 注释本行，gc9j 注释九行。 File Exploreplugins-setup.lua1use(&quot;nvim-tree/nvim-tree.lua&quot;) 在plugins文件夹中创建nvim-tree.lua，完成 setup 后在init.lua中 require通过:NvimTreeToggle或设置快捷键空格+e 调出 File Tree在光标在对应文件夹中时按 a 并在下方输入栏中输入文件名即可创建新文件 要支持 icon 使用： plugins-setup.lua1use(&quot;kyazdani42/nvim-web-devicons&quot;) Status lineplugins-setup.lua1use(&quot;nvim-lualine/lualine.nvim&quot;) 在plugins文件夹中创建lualine.lua，完成 setup 后在init.lua中 require Fuzzy findingplugins-setup.lua12use({&quot;nvim-telescope/telescope-fzf-native.nvim&quot;, run=&quot;make&quot;})use({&quot;nvim-telescope/telescope.nvim&quot;, branch=&quot;0.1.x&quot;}) 在plugins文件夹中创建telescope.lua，完成 setup 后在init.lua中 require keymaps 设置： 空格+ff 在项目中寻找文件(find files) 空格+fs 在项目中寻找文字 空格+fc 在项目中寻找当前的 string 空格+fb 显示 telescope 的 buffer 空格+fh 显示 telescope 的帮助 多个匹配通过Ctrl+j/k上下移动 Autocompletion and Snippetsplugins-setup.lua1234567use(&quot;hrsh7th/nvim-cmp&quot;)use(&quot;hrsh7th/cmp-buffer&quot;)use(&quot;hrsh7th/cmp-path&quot;)use(&quot;L3MON4D3/LuaSnip&quot;)use(&quot;saadparwaiz1/cmp_luasnip&quot;)use(&quot;rafamadriz/friendly-snippets&quot;) 在plugins文件夹中创建nvim-cmp.lua，完成 setup 后在init.lua中 require在补全建议中，通过Ctrl+j/k上下选择，Ctrl+b/f上下翻页，Ctrl+e关闭，回车选择 LSPplugins-setup.lua1234567891011121314151617-- managing &amp; installing lsp serversuse(&quot;williamboman/mason.nvim&quot;)use(&quot;williamboman/mason-lspconfig.nvim&quot;)-- configuring lsp serversuse(&quot;neovim/nvim-lspconfig&quot;)use(&quot;hrsh7th/cmp-nvim-lsp&quot;) -- for autocompletionuse({ &quot;glepnir/lspsaga.nvim&quot;, branch = &quot;main&quot;, requires = { { &quot;nvim-tree/nvim-web-devicons&quot; }, { &quot;nvim-treesitter/nvim-treesitter&quot; }, },}) -- enhanced lsp uisuse(&quot;jose-elias-alvarez/typescript.nvim&quot;) -- additional functionality for typescript server (e.g. rename file &amp; update imports)use(&quot;onsails/lspkind.nvim&quot;) -- vs-code like icons for autocompletion 在plugins文件夹中创建lua文件夹，然后在lua文件夹中创建mason.lua，完成 mason 的 setup 后指定需要 lsp 的语言，再在init.lua中 require 再在lua文件夹中创建lspconfig.lua，按照文档完成各 lsp 的配置后在init.lua中 require 再在lua文件夹中创建lspsaga.lua，设定Ctrl+f/b为上下翻页后，在init.lua中 require gf show definitions and references gD goto declaration gd see the definition and make edition gi goto implementation 空格+ca see available code actions 空格+rn smart rename 空格+D show diagnostics for line 空格+d show diagnostic for cursor [d jump to previous diagnostic in buffer ]d jump to next diagnostic in buffer K show documentation for what is under cursor 空格+o show outline on the right side formatting &amp; lintingplugins-setup.lua12use(&quot;jose-elias-alvarez/null-ls.nvim&quot;)use(&quot;jayp0521/mason-null-ls.nvim&quot;) 在lua文件夹中创建null-ls.lua，完成 setup 后在init.lua中 require Treesitter &amp; Auto closingplugins-setup.lua12345678910use({ &quot;nvim-treesitter/nvim-treesitter&quot;, run = function() local ts_update = require(&quot;nvim-treesitter.install&quot;).update({ with_sync = true }) ts_update() end,})use(&quot;windwp/nvim-autopairs&quot;) -- autoclose parens, brackets, quotes, etc...use({ &quot;windwp/nvim-ts-autotag&quot;, after = &quot;nvim-treesitter&quot; }) -- autoclose tags autopairs.lua + treesitter.lua git integrationplugins-setup.lua1use(&quot;lewis6991/gitsigns.nvim&quot;) gitsigns.lua TmuxTmux可以方便在一个界面内打开多个命令行窗口，我的配置同样是参考这位老哥的视频。 Command Line tmux new -s Session 创建并进入一个名为Session的 session tmux detach 退出 session tmux ls 列出当前所有 session tmux attach -t Session 进入已存在的名为Session的 session exit 关闭当前窗口 keymaps 设置prefix键为Ctrl+a prefix+s 显示所有 session 并可以通过 j/k 选择进入 prefix+| 生成垂直窗口 prefix+- 生成水平窗口 prefix+r 刷新配置 prefix+j/k/h/l 调整窗口大小 prefix+m 当前窗口最大化或恢复 Ctrl+j/k/h/l 光标在窗口间移动 prefix+c 创建新的窗口（全屏），随后可用 prefix+编号 进行窗口选择 prefix+, 进行重命名 prefix+p/n 前一个或后一个窗口 prefix+w 显示所有的 session 和窗口 命令行界面可以通过j/k上下移动，Ctrl+u/d上下半页，Ctrl+b/f上下页也可以通过y进行复制 prefix+I 下载插件","link":"/zh-CN/%E6%88%91%E7%9A%84neovim%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"C++14","slug":"C-14","link":"/tags/C-14/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"vim","slug":"vim","link":"/tags/vim/"}],"categories":[{"name":"Effective Modern C++","slug":"Effective-Modern-C","link":"/categories/Effective-Modern-C/"},{"name":"beginning","slug":"beginning","link":"/categories/beginning/"}],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"archives","text":"","link":"/archives/index.html"}]}