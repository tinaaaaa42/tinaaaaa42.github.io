{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"},{"title":"Effective Modern C++(1) 类型推导","text":"模板类型推导一个函数模板的伪代码类似这样： 12345template&lt;typename T&gt;void f(paramType param);// 调用f(expr); paramType 通常会带有一些修饰，比如const T&amp;等等。 情况一： paramType 是一个指针或引用，但不是通用引用12template&lt;typename T&gt;void f(T&amp; param); // param是一个引用 声明以下变量： 123int x = 42; // x是intconst int cx = x; // cx是const intconst int&amp; rx = cx; // rx是指向作为const int的x的引用 通过调用，类型推导如下： 123f(x); // T: int, param: int&amp;f(cx); // T: const int, param: const int&amp;f(rx); // T: const int, param: const int&amp; 根据上面的例子，在推导T时，常量型const-ness会被保留而引用性reference-ness会被忽略。 对paramType稍作变化也类似： 123456template&lt;typename T&gt;void f(const T&amp; param); // param现在是reference-to-constf(x); // T:int, param: const int&amp;f(cx); // T:int, param: const int&amp;f(rx); // T:int, param: const int&amp; 12345678template&lt;typename T&gt;void f(T* param) // param是指针int x = 42;const int *px = &amp;x; // px是指向作为const int的x的指针f(&amp;x); // T: int, param: int*f(px); // T: const int, param: const int* 情况二：paramType 是一个通用引用 如果expr是左值，T和paramType都会被推导为左值引用。这是模板类型推导唯一 T 被推导为引用的情况！ 如果expr是右值，则与情况一相同。 1234567891011template&lt;typename T&gt;void f(T&amp;&amp; param); // param是一个通用引用类型int x = 27;const int cx = x;const int&amp; rx = cx;f(x); // x是左值 =&gt; T: int&amp;, param: int&amp;f(cx); // cx是左值 =&gt; T: const int&amp;, param: const int&amp;f(rx); // rx是左值 =&gt; T: const int&amp;, param: const int&amp;f(42); // 42是右值 =&gt; T: int, param: int&amp;&amp; 情况三：paramType 既不是引用也不是指针此时通过传值pass-by-value的方式处理，也就是说 param 会作为一个完整的新对象，此时的到T的推导不仅忽略引用性reference-ness,常量性const-ness和volatile都会被忽略: 12345678910template&lt;typename T&gt;void f(T param); // 以传值的方式处理paramf(x); // T: int, param: intf(cx); // T: int, param: intf(rx); // T: int, param: intconst char* const ptr = &quot;Fun with pointers&quot;;// 此时ptr自身的值会传给形参f(ptr); // T/param: const char* 数组实参在函数参数中，数组常常会退化为指针。但利用引用，可以使得T推导为真正的数组！ 12345template&lt;typename T&gt;void f(T&amp; param);const char name[] = &quot;J, P, Briggs&quot;; // name类型为const char[13]f(name); // T: const char[13], param: const char (&amp;)[13] 根据这一点，我们还能写出推导数组大小的模板函数： 1234template&lt;typename T, std::size_t N&gt;constexpr std::size_t arraySize(T (&amp;)[N]) noexcept { return N;} autoauto声明的大部分情况与上述的模板类型推导相同： 123456789101112131415161718192021auto x = 27;const auto cx = x;const auto &amp; rx = cx;template&lt;typename T&gt; // 概念化的模板用来推导x的类型void func_for_x(T param);func_for_x(27); // 概念化调用(情景三) // param推导类型为x的类型template&lt;typename T&gt; // 概念化的模板用来推导cx的类型void func_for_cx(const T param);func_for_cx(x); // 概念化调用(情景三) // param推导类型为cx的类型template&lt;typename T&gt; // 概念化的模板用来推导rx的类型void func_for_rx(const T &amp; param);func_for_rx(cx); // 概念化调用(情景一) // param推导类型为rx的类型 情景二的例子： 123auto&amp;&amp; uref1 = x; // x是int左值 =&gt; uref1: int&amp;auto&amp;&amp; uref2 = cx; // cx是const int左值 =&gt; uref2: const int&amp;auto&amp;&amp; uref3 = 27; // 27是int右值 =&gt; uref3: int&amp;&amp; 对于non-reference类型说明符也是适用的： 123456789const char name[] = &quot;R. N. Briggs&quot;; // name是const char[13]auto arr1 = name; // arr1是const char*auto&amp; arr2 = name; // arr2是const char (&amp;)[13]void someFunc(int, double); // someFunc是类型为void(int, double)的函数auto func1 = someFunc; // func1是void (*)(int, double)auto&amp; func2 = someFunc; // func2是void (&amp;)(int, double) auto 的一个重要不同点是花括号的处理： 12auto x1 = {42};auto x2{42}; // 这两种初始化方式推导类型均为std::initializer_list&lt;int&gt; 而模板类型推导不会默认std::initializer_list&lt;T&gt;，事实上模板中无法处理: 123auto createInitList() { return {1, 2, 3}; // 无法通过编译！无法推导类型} 优先考虑auto声明而不是显式类型声明下面这个例子值得注意： 12345std::unordered_map&lt;std::string, int&gt; m;for (const std::pair&lt;std::string, int&gt;&amp; p : m) { // ...} 这样的写法会出现非常隐蔽的错误，因为hash table实际上存储的是std::pair&lt;const std::string, int&gt;，因此这里的p实际上是一份拷贝，而不是引用。如果我们使用auto声明，就不会出现这样的问题： 123for (const auto&amp; p : m) { // ...} auto的陷阱C++禁止对bit的引用，因此auto有一个典型的反例： 12345std::vector&lt;bool&gt; features(const Widget&amp; w);Widget w;auto highPriority = features(w)[5]; // highPriority是对bit的引用processWidget(w, highPriority); // 行为是不可预测的 std::vector&lt;bool&gt;的operator[]并不会返回bool的引用，而是返回了一个proxy对象std::vector&lt;bool&gt;::reference，由于该对象在这一行语句后被销毁，所以调用highPriority时会包含一个悬置dangling指针。 如果涉及到代理类的类型推导，一般可以使用显式类型初始器惯用法： 1auto highPriority = static_cast&lt;bool&gt;(features(w)[5]); decltypedecltype实际上只是返回参数的类型。在 C++11 中，它最主要就是用于声明函数模板，而返回类型依赖于形参类型： C++11的基本实现123456template&lt;typename Container, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) -&gt;decltype(c[i]) { // 使用了C++11的尾置返回类型语法 authenticateUser(); // 需要改良 return c[i];} C++14的基本实现(不那么正确)12345template&lt;typename Container, typename Index&gt;auto authAndAccess(Container&amp; c, Index i) { authenticateUser(); return c[i];} 由于模板类型推导时表达式的引用性的忽略，上面的这个实现并不正确，实际上可以这样写： C++14的基本实现123456template&lt;typename Container, typename Index&gt;decltype(auto) // C++14可以工作的版本authAndAccess(Container&amp; c, Index i) { // 还需要改进 authenticateUser(); return c[i];} 主要需要改进的地方就是处理右值，比如下面这样调用函数： 1234std::deque&lt;std::string&gt; makeStringDeque(); // 工厂函数// 从makeStringDeque中获得第五个元素的拷贝并返回auto s = authAndAccess(makeStringDeque(), 5); 除了重载的方法，我们也可以使用通用引用来实现： C++14的最终版本123456template&lt;typename Container, typename Index&gt;decltype(auto)authAndAccess(Container&amp;&amp; c, Index i) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} C++11的最终版本1234567template&lt;typename Container, typename Index&gt;autoauthAndAccess(Container&amp;&amp; c, Index i)-&gt;decltype(std::forward&lt;Container&gt;(x)[i]) { authenticateUser(); return std::forward&lt;Container&gt;(c)[i];} 查看类型推导除了直接通过 IDE 查看类型推导结果(可能并不准确)，还有以下的方式： 编译器诊断可以利用编译器出错时提供的错误信息来获取类型信息。比如这样声明一个类模板： 12template&lt;typename T&gt;class TD; // type displayer 要查看变量的类型，通过这样故意的错误实例化： 1TD&lt;decltype(x)&gt; xType; 然后就能根据编译器给出的信息来推断 x 的类型。 运行时输出 利用typeid(T).name()获取信息，但由于传值的特性，该结果并不一定准确。 使用Boost.TypeIndex库","link":"/zh-CN/Effective-Modern-C-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"},{"title":"icarus的一些用法","text":"本文引自https://blog.geektime.club/posts/8917 自定义效果突出提示栏 谷歌网址为www.google.com 本文同时提供如下语言的翻译：English 文章内容有误？请点击此处提交修改。 第一种-页面内提示123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-circle-info mr-2&quot;&gt;&lt;/i&gt;谷歌网址为&lt;a href=&quot;https://www.google.com&quot;&gt;www.google.com&lt;/a&gt; &lt;/div&gt;&lt;/article&gt; 下面这种方式实际实现的是站内的跳转，因此需要使用post_path变量。 第二种-站内跳转123456&lt;article class=&quot;message message-immersive is-primary&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-globe-asia mr-2&quot;&gt;&lt;/i&gt;本文同时提供如下语言的翻译：&lt;a href=&quot;&quot;&gt;English&lt;/a&gt; &lt;/div&gt;&lt;/article&gt; 第三种与第一种是类似的。 第三种 >folded123456&lt;article class=&quot;message message-immersive is-warning&quot;&gt; &lt;div class=&quot;message-body&quot;&gt; &lt;i class=&quot;fas fa-question-circle mr-2&quot;&gt;&lt;/i&gt;文章内容有误？请点击&lt;a href=&quot;https://github.com/tinaaaaa42&quot;&gt;此处&lt;/a&gt;提交修改。 &lt;/div&gt;&lt;/article&gt; 摘要要实现文章的摘要内容只显示在首页而不显示在正文，有以下两种办法： Front-matter可以将文章的摘要写在 md 文件开头的front-matter信息中： 文章xxx.md123456---......excerpt: 这里是摘要---这里是正文 Bulma也可以采用在正文中使用Bulma搭配 HTML 标签: 文章xxx.md1234567891011这里的内容会出现在简介和正文&lt;div class=&quot;post-summary&quot;&gt;这里的内容只会出现在简介&lt;/div&gt;&lt;!--more--&gt;&lt;style type=&quot;text/css&quot;&gt; .post-summary{ display:none; }&lt;/style&gt; 页内标签页页内标签页可以实现代码块的平行显示，即只会显示当前活跃的标签内容，比如icarus官网上的这个效果： 从源码安装 使用 从 Github 仓库安装… 使用 NPM 安装为 node 包… 具体实现代码如下： 页内标签页语法定义123456789101112131415{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签id&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签id&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %} tabs 第一页 第二页 这是small标签页容器的第一页 这是small标签页容器的第二页 第一页 第二页 这是默认标签页容器的第一页 这是默认标签页容器的第二页 第一页 第二页 这是medium标签页容器的第一页 这是medium标签页容器的第二页 第一页 第二页 这是large标签页容器的第一页 这是large标签页容器的第二页 align 第一页 第二页 这是默认标签页容器的第一页 这是默认标签页容器的第二页 第一页 第二页 这是centered标签页容器的第一页 这是centered标签页容器的第二页 第一页 第二页 这是right标签页容器的第一页 这是right标签页容器的第二页 第一页 第二页 这是fullwidth标签页容器的第一页 这是fullwidth标签页容器的第二页 style 第一页 第二页 这是boxed标签页容器的第一页 这是boxed标签页容器的第二页 第一页 第二页 这是toggle标签页容器的第一页 这是toggle标签页容器的第二页 第一页 第二页 这是toggle-rounded标签页容器的第一页 这是toggle-rounded标签页容器的第二页 彩色提示消息带颜色的消息提示能使信息更加醒目，其语法格式如下： 彩色消息提示语法定义123{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %}&lt;消息内容&gt;{% endmessage %} color default 这是默认颜色的消息块 dark 这是dark颜色的消息块 primary 这是primary颜色的消息块 info 这是info颜色的消息块 success 这是success颜色的消息块 warning 这是warning颜色的消息块 danger 这是danger颜色的消息块 size small 这是small大小的消息块 default 这是default大小的消息块 medium 这是medium大小的消息块 large 这是large大小的消息块 icon Github图标消息块 这是&quot;icon:fa-brands fa-github&quot;图标的消息块 Nodejs图标消息块 这是&quot;icon:fa-brands fa-node-js&quot;图标的消息块 title 这是没有title的消息块 Hexo 内置专用标签插件引用块123{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %} 代码块123{% codeblock [title] [lang:language] [url] [link text] [additional options] %}code snippet{% endcodeblock %} iframe1{% iframe url [width] [height] %} image1{% img [class names] /path/to/image [width] [height] '&quot;title text&quot; &quot;alt text&quot;' %} link1{% link text url [external] [title] %} youtube1234{% youtube video_id [type] [cookie] %}// [type]：默认为空，可选 playlist (播放列表)// [cookie]: 默认为true，可选false 一个例子：","link":"/zh-CN/icarus%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"},{"title":"我的neovim配置","text":"我的 neovim 配置基于油管上的这个视频，非常细致的老哥！ 在这一篇记录中不会涉及很多原理，基本用于个人的 cheat sheet。 Basic File Structure123456789101112131415~/.config/|__ nvim/ |__ init.lua |__ lua/ |__ young/ |__ core/ | |__ colorscheme.lua | |__ options.lua | |__ keymaps.lua |__ plugins/ | |__ lualine.lua | |__ telescope.lua | |__ nvim-tree.lua | |__ .... |__ plugins-setup.lua 基本 options 配置这部分内容在文件中比较容易看懂，也容易修改，不做赘述。 基本 keymaps 设置leader-key为空格 INSERT模式下按jk等同于&lt;ESC&gt;，即返回NORMAL模式 查找后通过空格+nh 跳转到特定位置并取消高亮 NORMAL模式下通过x删除不复制进 Clipboard NORMAL模式下通过空格+/-对值进行递增/递减 split windows(NORMAL模式) 空格+sv 生成竖直窗口 空格+sh 生成水平窗口 空格+se 使窗口等大 空格+sx 关闭当前窗口 tabs(NORMAL模式) 空格+to 打开新的 tab 空格+tx 关闭当前 tab 空格+tn 到下一个 tab 空格+tp 到前一个 tab Plugins使用Packer作为插件管理器，基本按照文档完成plugins-setup.lua文件的框架。并在init.lua文件最上方加入: 1require(&quot;young.plugins-setup&quot;) 配色plugins-setup.lua1use(&quot;bluz71/vim-nightfly-guicolors&quot;) 并在colorscheme.lua文件中指定。 Navigatorplugins-setup.lua1use(&quot;christoomey/vim-tmux-navigator&quot;) 通过Ctrl+h/j/k/l实现窗口间的移动 Maximizerplugins-setup.lua1use(&quot;szw/vim-maximizer&quot;) 在keymaps.lua中设置空格+sm 将当前窗口最大化或恢复 Essentialplugins-setup.lua12use(&quot;tpope/vim-surround&quot;)use(&quot;vim-scripts/ReplaceWithRegister&quot;) ys+w+” 在该单词两边加双引号 ds+” 去掉两边的双引号 cs+”+’ 将两边的双引号改为单引号 yw 复制当前词，grw 替换为复制的词 Commentplugins-setup.lua1use(&quot;numToStr/Comment.nvim&quot;) 在plugins文件夹中创建comment.lua，完成 setup 后在init.lua中 require 通过 gc+指定内容进行注释或者取消注释，如 gcc 注释本行，gc9j 注释九行。 File Exploreplugins-setup.lua1use(&quot;nvim-tree/nvim-tree.lua&quot;) 在plugins文件夹中创建nvim-tree.lua，完成 setup 后在init.lua中 require通过:NvimTreeToggle或设置快捷键空格+e 调出 File Tree在光标在对应文件夹中时按 a 并在下方输入栏中输入文件名即可创建新文件 要支持 icon 使用： plugins-setup.lua1use(&quot;kyazdani42/nvim-web-devicons&quot;) Status lineplugins-setup.lua1use(&quot;nvim-lualine/lualine.nvim&quot;) 在plugins文件夹中创建lualine.lua，完成 setup 后在init.lua中 require Fuzzy findingplugins-setup.lua12use({&quot;nvim-telescope/telescope-fzf-native.nvim&quot;, run=&quot;make&quot;})use({&quot;nvim-telescope/telescope.nvim&quot;, branch=&quot;0.1.x&quot;}) 在plugins文件夹中创建telescope.lua，完成 setup 后在init.lua中 require keymaps 设置： 空格+ff 在项目中寻找文件(find files) 空格+fs 在项目中寻找文字 空格+fc 在项目中寻找当前的 string 空格+fb 显示 telescope 的 buffer 空格+fh 显示 telescope 的帮助 多个匹配通过Ctrl+j/k上下移动 Autocompletion and Snippetsplugins-setup.lua1234567use(&quot;hrsh7th/nvim-cmp&quot;)use(&quot;hrsh7th/cmp-buffer&quot;)use(&quot;hrsh7th/cmp-path&quot;)use(&quot;L3MON4D3/LuaSnip&quot;)use(&quot;saadparwaiz1/cmp_luasnip&quot;)use(&quot;rafamadriz/friendly-snippets&quot;) 在plugins文件夹中创建nvim-cmp.lua，完成 setup 后在init.lua中 require在补全建议中，通过Ctrl+j/k上下选择，Ctrl+b/f上下翻页，Ctrl+e关闭，回车选择 LSPplugins-setup.lua1234567891011121314151617-- managing &amp; installing lsp serversuse(&quot;williamboman/mason.nvim&quot;)use(&quot;williamboman/mason-lspconfig.nvim&quot;)-- configuring lsp serversuse(&quot;neovim/nvim-lspconfig&quot;)use(&quot;hrsh7th/cmp-nvim-lsp&quot;) -- for autocompletionuse({ &quot;glepnir/lspsaga.nvim&quot;, branch = &quot;main&quot;, requires = { { &quot;nvim-tree/nvim-web-devicons&quot; }, { &quot;nvim-treesitter/nvim-treesitter&quot; }, },}) -- enhanced lsp uisuse(&quot;jose-elias-alvarez/typescript.nvim&quot;) -- additional functionality for typescript server (e.g. rename file &amp; update imports)use(&quot;onsails/lspkind.nvim&quot;) -- vs-code like icons for autocompletion 在plugins文件夹中创建lua文件夹，然后在lua文件夹中创建mason.lua，完成 mason 的 setup 后指定需要 lsp 的语言，再在init.lua中 require 再在lua文件夹中创建lspconfig.lua，按照文档完成各 lsp 的配置后在init.lua中 require 再在lua文件夹中创建lspsaga.lua，设定Ctrl+f/b为上下翻页后，在init.lua中 require gf show definitions and references gD goto declaration gd see the definition and make edition gi goto implementation 空格+ca see available code actions 空格+rn smart rename 空格+D show diagnostics for line 空格+d show diagnostic for cursor [d jump to previous diagnostic in buffer ]d jump to next diagnostic in buffer K show documentation for what is under cursor 空格+o show outline on the right side formatting &amp; lintingplugins-setup.lua12use(&quot;jose-elias-alvarez/null-ls.nvim&quot;)use(&quot;jayp0521/mason-null-ls.nvim&quot;) 在lua文件夹中创建null-ls.lua，完成 setup 后在init.lua中 require Treesitter &amp; Auto closingplugins-setup.lua12345678910use({ &quot;nvim-treesitter/nvim-treesitter&quot;, run = function() local ts_update = require(&quot;nvim-treesitter.install&quot;).update({ with_sync = true }) ts_update() end,})use(&quot;windwp/nvim-autopairs&quot;) -- autoclose parens, brackets, quotes, etc...use({ &quot;windwp/nvim-ts-autotag&quot;, after = &quot;nvim-treesitter&quot; }) -- autoclose tags autopairs.lua + treesitter.lua git integrationplugins-setup.lua1use(&quot;lewis6991/gitsigns.nvim&quot;) gitsigns.lua TmuxTmux可以方便在一个界面内打开多个命令行窗口，我的配置同样是参考这位老哥的视频。 Command Line tmux new -s Session 创建并进入一个名为Session的 session tmux detach 退出 session tmux ls 列出当前所有 session tmux attach -t Session 进入已存在的名为Session的 session exit 关闭当前窗口 keymaps 设置prefix键为Ctrl+a prefix+s 显示所有 session 并可以通过 j/k 选择进入 prefix+| 生成垂直窗口 prefix+- 生成水平窗口 prefix+r 刷新配置 prefix+j/k/h/l 调整窗口大小 prefix+m 当前窗口最大化或恢复 Ctrl+j/k/h/l 光标在窗口间移动 prefix+c 创建新的窗口（全屏），随后可用 prefix+编号 进行窗口选择 prefix+, 进行重命名 prefix+p/n 前一个或后一个窗口 prefix+w 显示所有的 session 和窗口 命令行界面可以通过j/k上下移动，Ctrl+u/d上下半页，Ctrl+b/f上下页也可以通过y进行复制 prefix+I 下载插件","link":"/zh-CN/%E6%88%91%E7%9A%84neovim%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"C++14","slug":"C-14","link":"/tags/C-14/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"vim","slug":"vim","link":"/tags/vim/"}],"categories":[{"name":"Effective Modern C++","slug":"Effective-Modern-C","link":"/categories/Effective-Modern-C/"},{"name":"beginning","slug":"beginning","link":"/categories/beginning/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}